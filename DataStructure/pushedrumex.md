<details>
  <summary>1. 퀵 정렬 알고리즘에 대해 설명해주세요.</summary>
  퀵정렬은 피벗을 기준으로 작은 값은 왼쪽, 큰 값을 오른쪽으로 이동하는 과정을 재귀적으로 수행하는 알고리즘입니다.
  파티셔닝을 하는 과정에서 n번, 분할하는 과정에서 lon(n)번의 연산이 수행되므로 시간복잡도는 nlon(n)입니다.
</details>
<details>
  <summary>1-1. 퀵 정렬에서 최악의 경우는 어떤 경우이고 그때의 시간복잡도가 어떻게 되나요?</summary>
  최대값이나 최소값을 피벗으로 선택하는 경우 배열의 길이가 1이 될 때까지 n-1번을 분할해야하므로 최악의 경우 시간복잡도는 O(n^2)입니다.
</details>
<details>
  <summary>1-2. 병합 정렬 알고리즘에 대해 설명해주세요.</summary>
  원소가 하나만 남을 때까지 계속해서 분할한 다음 대소관계를 고려해서 재배열하여 병합하는 알고리즘으로
  분할하는 과정에서 log(n)번, 재배열하는 과정에서 n번의 연산이 수행되므로 시간복잡도는 nlog(n)입니다.
</details>
<details>
  <summary>1-3. 퀵 정렬과 병합 정렬은 동일한 성능을 갖나요?</summary>
  참조 지역성의 원리에 따라 퀵 정렬이 병합 정렬보다 캐시 메모리에 자주 접근하므로 병합 정렬보다 성능이 더 좋습니다.
</details>

---

<details>
  <summary>2. 힙 자료 구조에 대해 설명해주세요.</summary>
  완전 이진 트리를 기반의 자료 구조입니다. 최소 힙의 경우, 부모 노드의 값이 자식 노드의 값보다 작거나 같습니다.
</details>
<details>
  <summary>2-1. 힙 자료구조에 데이터가 추가되는 과정을 설명해주세요.</summary>
  트리의 마지막 레벨의 가장 왼쪽에 새로운 노드를 추가하고, 그 노드 값과 부모 노드의 값을 비교하여 정렬을 수행합니다. 이 때의 시간 복잡도는 트리의 높이인 log(n)입니다.
</details>

---

<details>
  <summary>3. 해시란 무엇인가요?</summary>
  데이터를 저장할 위치를 해시 함수로 계산하여 저장하는 자료구조입니다. 키를 해시화하여 값에 접근하므로 O(1)의 시간복잡도를 갖습니다.
</details>
<details>
  <summary>3-1. 해시 충돌이란 무엇인가요?</summary>
  키를 통해 얻은 해시값이 다른 키의 해시값과 동일하여 발생하는 상황입니다.
</details>
<details>
  <summary>3-2. 해시 충돌을 해결할 수 있는 방법에는 어떤게 있나요?</summary>
  
    - 체이닝: 연결리스트로 데이터를 연결하는 방식
    - 오픈 주소법: 다른 비어있는 버킷에 데이터를 저장하는 방식
</details>
<details>
  <summary>3-3. 오픈 주소법의 장단점에 대해 설명해주세요.</summary>
  추가적인 메모리를 사용하지 않는다는 장점이 있고, 충돌이 많이 발생할 경우 비어있는 버킷을 탐색하는데 많은 시간이 소요된다는 단점이 있습니다.
</details>
<details>
  <summary>3-4. 체이닝의 장단점에 대해 설명해주세요.</summary>
  구현이 간단하다는 장점이 있고, 추가적인 메모리를 사용해야하고 충돌이 많이 발생할 경우 조회 성능이 O(N)에 가까워진다는 단점이 있습니다.
</details>
<details>
  <summary>3-5. 해시 충돌이 자주 발생한다면 어떻게 하면 좋을까요?</summary>
  데이터를 좀 더 균등하게 분배해주는 해시 함수로 변경하거나, 체이닝을 사용한다면 연결리스트에서 트리로 변경하고 최악의 경우의 조회 시간 복잡도를 O(N)를 O(logN)로 개선할 수 있습니다.
</details>

---

<details>
  <summary>4. 자료구조에서 그래프란 무엇인가요?</summary>
  노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조입니다.
</details>
<details>
  <summary>4-1. 그래프와 트리의 차이가 무엇인가요?</summary>
  그래프는 방향이 없고 트리는 부모 자식관계와 루트 노드가 존재하며 방향성이 존재합니다. 또한 그래프는 순환이 존재할 수 있지만, 트리는 비순환성을 갖습니다.
</details>

---

<details>
  <summary>5. 이진 트리란 무엇인가요?</summary>
  모든 노드들이 2개 이하의 자식을 갖는 트리입니다.
</details>
<details>
  <summary>5-1. 이진 탐색 트리(BST)란 무엇인가요?</summary>
  왼쪽 자식은 부모보다 작고 오른쪽 자식은 부모보다 큰 이진트리입니다. 일반적으로 삽입, 삭제, 탐색 과정에서 log(n)의 시간 복잡도를 갖지만, 트리가 편향될 경우 시간복잡도는 n이 됩니다.
</details>
<details>
  <summary>5-2. 높이 균형 이진 탐색 트리(AVL)란 무엇인가요?</summary>
  AVL 트리는 트리 높이의 균형을 유지하는 이진 탐색 트리입니다. 왼쪽과 오른쪽 서브 트리의 높이 차이가 최대 1을 유지합니다. 높이 차이가 1보다 커지면 회전을 통해 균형을 잡아 높이 차이를 줄입니다.
  회전은 불균형 노드를 기준으로 서브트리의 위치를 변경하여 균형을 맞추는 과정입니다.
</details>
<details>
  <summary>5-3. 레드 블랙 트리(RBT)란 무엇인가요?</summary>
  레드 블랙 트리는 트리 높이의 균형을 유지하는 이진 탐색 트리입니다. 각 노드의 색상을 빨간색 또는 검은색으로 구성하여 삽입과 삭제 수행 시, 규칙에 만게 재배치하여 균형을 유지합니다. 
</details>

---

<details>
  <summary>6. B-트리란 무엇인가요?</summary>
  하나의 노드에 2개 이상의 데이터를 저장할 수 있는 트리입니다. 트리의 높이를 줄여 탐색 시간을 개선한 구조입니다. 부모 노드의 데이터를 기준으로 자식 노드를 정렬하여 배치됩니다. 또한 스스로 균형을 맞추는 로직을 갖추어 log(n) 의 시간 복잡도를 보장합니다.
</details>
<details>
  <summary>6-1. B-트리와 B+트리의 차이가 무엇인가요?</summary>
  B+트리는 B-트리를 확장한 개념으로 B-트리는 모든 노드에 key와 데이터를 담지만 B+트리는 리프 노드에만 key와 data를 저장하며 리프 노드끼리 linkedlist로 연결되어 있습니다.
</details>
<details>
  <summary>6-2. InnoDB는 인덱스를 저장할 때 어떤 자료구조를 사용하나요?</summary>
  리프 노드 끼리 연결 리스트로 구성되어 순차 접근을 효율적으로 할 수 있는 B+트리를 사용합니다.
</details>

---

<details>
  <summary>7. 배열의 특징에는 어떤것이 있나요?</summary>
  고정된 저장 공간을 갖고, 인덱스로 접근 가능하다는 특징이 있습니다.
</details>
<details>
  <summary>7-1. 배열의 장점과 단점에 대해 설명해주세요.</summary>
  랜덤 인덱스로 O(1)의 시간복잡도로 데이터를 조회할 수 있다는 장점이 있습니다. 하지만, 데이터를 삽입하거나 삭제할 때 O(N)이 걸린다는 단점이 있습니다.
</details>
<details>
  <summary>7-2. 배열과 연결 리스트의 차이점에 대해 설명해주세요.</summary>
  메모리에 저장되는 방식 이에 따른 연산 속도 차이가 있습니다. 배열은 메모리에 연속적으로 저장되고 연결 리스트는 불연속적으로 저장되며 각가의 원소는 다음 원소의 주소값을 저장합니다.
  따라서 데이터 조회의 경우 배열은 O(1) 연결 리스트는 O(N), 데이터 삽입/삭제의 경우 배열은 O(N) 연결 리스트는 O(1)이 소요됩니다.  
</details>

---

<details>
  <summary>8. BFS와 DFS에 대해 설명해주세요.</summary>
  BFS는 현재 노드와 연결되어있는 노드부터 차례대로 탐색하는 방법이고, DFS는 갈 수 있는 한 끝까지 탐색해 리프 노드를 방문하고, 이전 갈림길로 돌아와 선택하지 않았던 노드를 방문하는 식으로 탐색하는 방법입니다.
</details>
<details>
  <summary>8-1. 각각 어떻게 구현할 수 있나요?</summary>
  BFS는 큐를 사용하여 구현할 수 있고 DFS는 재귀를 사용하여 구현할 수 있습니다.
</details>
<details>
  <summary>8-2. 각각 어떤 상황에 사용하면 좋을까요?</summary>
  각 경로마다 특징을 저장해야하는 경우 DFS가 적절하고, 최단거리를 구해야하는 경우 BFS가 적절합니다.
</details>

---

<details>
  <summary>9. Stack 과 Queue에 대해 설명해주세요.</summary>
  스택은 마지막에 들어온 데이터를 먼저 꺼내는 후입선출의 자료구조이고, 큐는 먼저 들어온 데이터를 먼저 꺼내는 선입선출의 자료구조입니다.
</details>
<details>
  <summary>9-1. Stack 이 사용되는 예시를 설명해주세요.</summary>
  함수 호출, 브라우저의 뒤로가기, 실행 취소 등에서 사용할 수 있습니다.
</details>
<details>
  <summary>9-2. Queue 가 사용되는 예시를 설명해주세요.</summary>
  BFS, 대기열 등에서 사용할 수 있습니다.
</details>
<details>
  <summary>9-3. Stack 으로 Queue 를 구현해보세요.</summary>
  두 개의 스택으로 큐를 구현할 수 있습니다. enqueue를 할 때는 1번 스택에 push 하고, dequeue을 할 때는 2번 스택에서 pop을 합니다.
  2번 스택에 비어있다면, 1번 스택에 저장된 데이터를 pop하여 2번 스택에 push한 후, pop을 합니다.
</details>
<details>
  <summary>9-4. Queue 로 Stack 을 구현해보세요.</summary>
  두 개의 큐로 스택을 구현할 수 있습니다. push를 할 때는 1번 큐에 enqueue 를 하고, pop을 할 때는 1번 큐에 있는 마지막 데이터를 제외하고 dequeue하여 2번 큐에 옯기고, 마지막 데이터를 dequeue합니다. 이후 1번 큐와 2번 큐를 스왑합니다.
</details>

---

<details>
  <summary>10. 큐와 우선순위 큐는 어떤 차이가 있나요?</summary>
  큐는 시간 순서상 먼저 넣은 데이터를 가장 먼저 나오는 선입선출 구조로 데이터를 관리합니다. 이와 달리 우선순위 큐는 넣은 순서와 상관 없이 우선순위가 높은 데이터가 가장 먼저 나옵니다.
</details>
<details>
  <summary>10-1. 우선순위 큐는 어떻게 구현할 수 있을까요?</summary>
  배열이나 힙으로 구현할 수 있습니다. 배열로 구현할 경우 push 는 O(1)이 소요되고, pop 은 O(N)이 소요됩니다. 힙으로 구현할 경우 push, pop 모두 log(N)이 소요됩니다. 
</details>

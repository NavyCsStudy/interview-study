<details>
  <summary>1. 퀵 정렬 알고리즘에 대해 설명해주세요.</summary>
  퀵정렬은 피벗을 기준으로 작은 값은 왼쪽, 큰 값을 오른쪽으로 이동하는 과정을 재귀적으로 수행하는 알고리즘입니다.
  파티셔닝을 하는 과정에서 n번, 분할하는 과정에서 lon(n)번의 연산이 수행되므로 시간복잡도는 nlon(n)입니다.
</details>
<details>
  <summary>1-1. 퀵 정렬에서 최악의 경우는 어떤 경우이고 그때의 시간복잡도가 어떻게 되나요?</summary>
  최대값이나 최소값을 피벗으로 선택하는 경우 배열의 길이가 1이 될 때까지 n-1번을 분할해야하므로 최악의 경우 시간복잡도는 O(n^2)입니다.
</details>
<details>
  <summary>1-2. 병합 정렬 알고리즘에 대해 설명해주세요.</summary>
  원소가 하나만 남을 때까지 계속해서 분할한 다음 대소관계를 고려해서 재배열하여 병합하는 알고리즘으로
  분할하는 과정에서 log(n)번, 재배열하는 과정에서 n번의 연산이 수행되므로 시간복잡도는 nlog(n)입니다.
</details>
<details>
  <summary>1-3. 퀵 정렬과 병합 정렬은 동일한 성능을 갖나요?</summary>
  참조 지역성의 원리에 따라 퀵 정렬이 병합 정렬보다 캐시 메모리에 자주 접근하므로 병합 정렬보다 성능이 더 좋습니다.
</details>

---

<details>
  <summary>2. 힙 자료 구조에 대해 설명해주세요.</summary>
  완전 이진 트리를 기반의 자료 구조입니다. 최소 힙의 경우, 부모 노드의 값이 자식 노드의 값보다 작거나 같습니다.
</details>
<details>
  <summary>2-1. 힙 자료구조에 데이터가 추가되는 과정을 설명해주세요.</summary>
  트리의 마지막 레벨의 가장 왼쪽에 새로운 노드를 추가하고, 그 노드 값과 부모 노드의 값을 비교하여 정렬을 수행합니다. 이 때의 시간 복잡도는 트리의 높이인 log(n)입니다.
</details>

---

<details>
  <summary>3. 해시란 무엇인가요?</summary>
  데이터를 저장할 위치를 해시 함수로 계산하여 저장하는 자료구조입니다. 키를 해시화하여 값에 접근하므로 O(1)의 시간복잡도를 갖습니다.
</details>
<details>
  <summary>3-1. 해시 충돌이란 무엇인가요?</summary>
  키를 통해 얻은 해시값이 다른 키의 해시값과 동일하여 발생하는 상황입니다.
</details>
<details>
  <summary>3-2. 해시 충돌을 해결할 수 있는 방법에는 어떤게 있나요?</summary>
  
    - 체이닝: 연결리스트로 데이터를 연결하는 방식
    - 오픈 주소법: 다른 비어있는 버킷에 데이를 저장하는 방식
</details>

---

<details>
  <summary>4. 자료구조에서 그래프란 무엇인가요?</summary>
  노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조입니다.
</details>
<details>
  <summary>4-1. 그래프와 트리의 차이가 무엇인가요?</summary>
  그래프는 방향이 없고 트리는 부모 자식관계와 루트 노드가 존재하며 방향성이 존재합니다. 또한 그래프는 순환이 존재할 수 있지만, 트리는 비순환성을 갖습니다.
</details>

---

<details>
  <summary>5. 이진 트리란 무엇인가요?</summary>
  모든 노드들이 2개 이하의 자식을 갖는 트리입니다.
</details>
<details>
  <summary>5-1. 이진 탐색 트리(BST)란 무엇인가요?</summary>
  왼쪽 자식은 부모보다 작고 오른쪽 자식은 부모보다 큰 이진트리입니다. 일반적으로 삽입, 삭제, 탐색 과정에서 log(n)의 시간 복잡도를 갖지만, 트리가 편향될 경우 시간복잡도는 n이 됩니다.
</details>
<details>
  <summary>5-2. 높이 균형 이진 탐색 트리(AVL)란 무엇인가요?</summary>
  AVL 트리는 트리 높이의 균형을 유지하는 이진 탐색 트리입니다. 왼쪽과 오른쪽 서브 트리의 높이 차이가 최대 1을 유지합니다. 높이 차이가 1보다 커지면 회전을 통해 균형을 잡아 높이 차이를 줄입니다.
  회전은 불균형 노드를 기준으로 서브트리의 위치를 변경하여 균형을 맞추는 과정입니다.
</details>
<details>
  <summary>5-3. 레드 블랙 트리(RBT)란 무엇인가요?</summary>
  레드 블랙 트리는 트리 높이의 균형을 유지하는 이진 탐색 트리입니다. 각 노드의 색상을 빨간색 또는 검은색으로 구성하여 삽입과 삭제 수행 시, 규칙에 만게 재배치하여 균형을 유지합니다. 
</details>

---

<details>
  <summary>6. B-트리란 무엇인가요?</summary>
  하나의 노드에 2개 이상의 데이터를 저장할 수 있는 트리입니다. 트리의 높이를 줄여 탐색 시간을 개선한 구조입니다. 부모 노드의 데이터를 기준으로 자식 노드를 정렬하여 배치됩니다. 또한 스스로 균형을 맞추는 로직을 갖추어 log(n) 의 시간 복잡도를 보장합니다.
</details>
<details>
  <summary>6-1. B-트리와 B+트리의 차이가 무엇인가요?</summary>
  B+트리는 B-트리를 확장한 개념으로 B-트리는 모든 노드에 key와 데이터를 담지만 B+트리는 리프 노드에만 key와 data를 저장하며 리프 노드끼리 linkedlist로 연결되어 있습니다.
</details>
<details>
  <summary>6-2. InnoDB는 인덱스를 저장할 때 어떤 자료구조를 사용하나요?</summary>
  리프 노드 끼리 연결 리스트로 구성되어 순차 접근을 효율적으로 할 수 있는 B+트리를 사용합니다.
</details>

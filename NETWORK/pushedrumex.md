<details>
  <summary>1. HTTP 요청 메시지는 어떻게 구성되어있는지 설명해주세요.</summary>
  HTTP 요청 메시지는 메소드, HTTP 버전, 헤더값, 메시지 본문으로 구성되어있습니다.
</details>
<details>
  <summary>1-1. HTTP 응답 메시지는 어떻게 구성되어있는지 설명해주세요</summary>
  HTTP 응답 메시지는 상태 코드, 응답 문구, HTTP 버전, 헤더값, 메시지 본문으로 구성되어있습니다.
</details>
<details>
  <summary>1-2. HTTP 응답코드란 무엇이고 어떤것들이 있나요?</summary>
  HTTP 응답 코드란, 클라이언트가 서버에 요청을 보낸 후 서버에서 클라이언트로 반환되는 상태코드입니다.

    - 100번대: 요청이 처리 중
    - 200번대: 요청이 성공적으로 처리되었음
    - 300번대: 리다이렉션
    - 400번대: 클라이언트의 잘못된 요청
    - 500번대: 서버에서 문제 발생
</details>

---

<details>
  <summary>2. REST API 에서 REST 란 무엇인가요?</summary>
  REST 는 Representational State Transfer 의 약자로, 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미합니다.
  즉, URI 를 통해 자원을 명시하고 Method를 통해 URI에 대한 CRUD를 적용하는 것을 의미합니다.

</details>
<details>
  <summary>2-1. URI 과 URL 의 차이가 무엇인가요?</summary>
  URI 는 uniform resource identifier 로 자원을 구분하는 식별자이며, URL 은 uniform resource location 으로 자원의 위치를 나타낸 것입니다. URI 은 URL을 포함합니다.
</details>
<details>
  <summary>2-2. HTTP Method 에는 어떤 것들이 있나요?</summary>
  
    1.GET: URI로 지정한 정보를 요청 
    2.POST: 클라이언트에서 서버로 데이터 송신
    3.PUT: 리소스의 전체 내용을 업데이트, 리소스가 존재하지 않을 경우 새로 생성
    4.PATCH: 리소스의 일부를 업데이트
    5.DELETE: 리소스를 삭제
</details>

---

<details>
  <summary>3. TCP/IP 4계층에 대해 설명해주세요.</summary>
  TCP/IP 4계층은 응용 계층, 전송 계층, 인터넷 계층, 네트워크 접근 계층으로 구성되어 있습니다.
  
  1. 응용 계층

    - 어플리케이션끼리의 데이터 송수신을 담당하는 계층
    - 데이터 단위: 데이터 / 메시지
    - HTTP, DNS
  2. 전송 계층

    - 데이터 전송과 흐름의 신뢰성을 보장하는 계층
    - 데이터 단위: 세그먼트
    - 헤더: 송수신 측의 포트번호, 시퀀스 번호, ACK 번호 컨트롤 비트
    - TCP, UDP
  3. 인터넷 계층
    
    - 네트워크 상에서 데이터를 전송하는 계층
    - 데이터 단위: 패킷
    - 헤더: 송수신 측의 IP 주소
    - IP, ARP(IP 주소에 해당하는 MAC 주소를 얻는 방법)
  
  4. 네트워크 접근 계층

    - 물리적인 데이터를 전송하는 계층
    - 데이터 단위: 프레임
    - 헤더: MAC
    - MAC, LAN

</details>
<details>
  <summary>3-1. TCP 와 UDP 차이가 무엇인가요?</summary>
  TCP는 신뢰성 있는 데이터 전송을 지원하는 연결형 프로토콜로 3-way handshake 과정을 통해 통신합니다. 
  데이터의 전송 순서를 보장하며 신뢰성있는 데이터를 전송할 수 있습니다.
  UDP는 비연결형 프로토콜로, 보내는 쪽에서 일방적으로 데이터를 전달합니다. handshaking 같은 과정을 거치지 않고 수신을 확인하는 과정이 없습니다.
</details>
<details>
  <summary>3-2. UDP의 통신 예시 하나만 설명해주세요.</summary>
  UDP는 데이터가 한 개의 패킷에 수용할 수 있을 만큼 짧거나 누락된 패킷을 재전송할 필요가 없을 경우 사용됩니다.
  DNS 통신의 경우 패킷이 작기 때문에 UDP를 사용하고, 음성이나 영상 데이터일 경우 재전송의 의미가 없기 때문에 UDP를 사용합니다.
</details>

---

<details>
  <summary>4. IP 주소란 무엇인가요?</summary>
  네트워크 상에서 컴퓨터를 식별하기 위한 주소입니다. IP 주소는 32비트로 구성되어있으며 8비트씩 점으로 구분하여 10진수로 표기됩니다. IP 주소는 네트워크 번호와 호스트 번호로 이루어져 있습니다. 
</details>
<details>
  <summary>4-1. 넷마스크란 무엇인가요?</summary>
  IP 주소에서 어느 부분이 네트워크 번호이고 어느 부분이 호스트 번호인지 표시하기 위한 방법입니다.
</details>
<details>
  <summary>4-2. 포트번호가 필요한 이유가 무엇인가요?</summary>
  IP 주소는 네트워크의 어느 컴퓨터인지만 나타내기 때문에 컴퓨터 내의 소켓을 지정하기 위해 포트번호가 필요합니다.
</details>
<details>
  <summary>4-3. 도메인 주소와 IP 주소를 구분하여 사용하는 이유가 무엇인가요?</summary>
  IP주소를 모두 기억하기 어렵기 때문에 도메인 주소를 사용합니다. 또한, 도메인명으로만 통신을 할경우 도메인명의 길이에 따라 라우터에 부하가 발생하기 때문에 4바이트의 IP 주소를 사용합니다.
</details>

---

<details>
  <summary>5. 3-way handshake 과정을 설명해주세요.</summary>
  3-way handshake 는 연결을 수립하기 위한 과정입니다.
    
  1. 클라이언트가 SYN 비트를 1로 설정하여 TCP 헤더를 생성하여 서버에게 전달합니다.
  2. 서버에서 SYN 와 ACK 비트를 1로 설정하여 클라이언트에게 반송합니다.
  3. 클라이언트는 전송한 패킷이 도착했다는 것을 알리기 위해 ACK 를 1로 만들어 반송합니다. 
</details>
<details>
  <summary>5-1. 4-way handshake 과정을 설명해주세요.</summary>
  4-way handshake 는 연결을 끊기 위한 과정입니다.

  1. 서버는 FIN 비트를 1로 설정하고 클라이언트에게 전달합니다.
  2. 클라이언트는 ACK 비트를 1로 설정하고 반송합니다.
  3. 클라이언트는 데이터 수신이 완료되면 FIN 비트를 1로 설정하여 전달합니다.
  4. 서버는 ACK 비트를 1로 설정하여 반송합니다. 
</details>
<details>
  <summary>5-2. 4-way handshake 에서 클라이언트가 ACK 와 FIN 을 같이 반송하지 않는 이유가 무엇인가요?</summary>
  서버에서 보낸 데이터 수신이 완료되지 않았을 수도 있기 때문입니다.
</details>
<details>
  <summary>5-3. SSL handshake 과정을 설명해주세요.</summary>
  
  1. 클라이언트가 지원가능한 암호화 방식 목록을 서버에게 전달
  2. 서버는 암호화 목록 중 하나를 선택한 것과, ssl 인증서를 클라이언트에게 전달
  3. 클라이언트는 CA에서 공유하는 공개키로 ssl 인증서를 복호화하여 검증
  4. 클라이언트는 임시로 만든 대칭키를 ssl에 들어있는 서버의 공개키로 암호화하여 서버에게 전달
  5. 서버는 자신의 개인키로 복호화하여 대칭키 획득
  6. 클라이언트와 서버는 이 대칭키로 데이터를 암호화/복호화하며 통신 
</details>

---

<details>
  <summary>6. 흐름 제어에 대해 설명해주세요</summary>
  흐름 제어란 송신측과 수신측 사이의 데이터 처리 속도 차이를 해결하기 위한 기법입니다.
</details>
<details>
  <summary>6-1. 흐름 제어 방법에는 어떤 것들이 있나요?</summary>
  
  1. 정지 대기: 전송한 패킷에 대한 응답을 받은 후 다음 패킷 전송
  2. 슬라이딩 윈도우: 수신측의 수신 가능한 데이터의 양인 윈도우 값을 기반으로 연속해서 복수의 패킷을 보내는 방법

</details>
<details>
  <summary>6-2. 혼잡 제어에 대해서 설명해주세요.</summary>
  네트워크 혼잡을 피하기 위해 송신 측에서 데이터의 전송 속도를 강제로 제어하는 방법입니다.
</details>
<details>
  <summary>6-3. 혼잡 제어 방법에는 어떤 것들이 있나요?</summary>
  
  1. 합 증가 곱 감소: 패킷을 하나씩 보내고 문제가 없다면 윈도우 크기를 1씩 증가, 실패하면 윈도우 크기를 반으로 감소
  2. slow start: 윈도를 2배씩 증가하고 혼잡이 감지되면 윈도우 크키를 1로 줄임
</details>

---

<details>
  <summary>7. CORS에러는 언제 발생하나요</summary>
  브라우저에서 다른 출처를 갖는 서버로 요청이 갈 때 발생합니다.
</details>
<details>
  <summary>7-1. CORS 에러가 발생하는 이유는 무엇인가요?</summary>
  같은 출처의 리소스만 공유하도록하는 정책인 SOP 정책에 의해 발생합니다.
  SOP는 브라우저에는 토큰과 같은 인증 정보가 저장될 수 있는데, 피싱 메일이나 악성 사이트에 의해 해당 정보가 노출될 위험을 방지하기 위해 존재하는 정책입니다.
</details>
<details>
  <summary>7-2. CORS 에러가 발생하는 과정에 대해 설명해주세요.</summary>
  
  1. 클라이언트가 다른 출처를 같은 서버에 요청 메시지를 전송합니다.
  2. 서버에서 Access-Control-Allow-Origin 헤더에 허용하는 Origin 을 명시하여 응답합니다.
  3. 응답을 받은 브라우저는 해당 헤더값이 자신의 Origin과 다르면 CORS 에러를 발생시킵니다.

</details>
<details>
  <summary>7-3. CORS 에러를 해결하는 방법에 대해 설명해주세요</summary>
  서버에서 CORS 와 관련된 응답 헤더에 허용할 출처를 명시하여 해결할 수 있습니다.
</details>

---

<details>
  <summary>8. 로그인에서 사용되는 쿠키와 세션 방식에 대해 설명해주세요.</summary>
  
  - 쿠키: 서버는 HTTP 응답에 사용자를 식별할 수 있는 정보가 담긴 쿠키를 응답하고, 이후 브라우저는 요청에 해당 쿠키를 동봉하여 서버에 전달
  - 세션 : 서버는 세션ID를 쿠키에 담아 응답하고, 사용자 정보는 서버에 저장. 이후 브라우저는 세션ID를 동봉하여 서버에 전달
</details>
<details>
  <summary>8-1. 쿠키와 세션의 단점에 대해 설명해주세요</summary>

  - 쿠키 : 쿠키에 보관된 사용자의 정보가 유출될 위험성이 존재
  - 세션 : 사용자 정보를 서버측에 저장하여 추가적인 메모리가 필요

</details>
<details>
  <summary>8-2. 쿠키나 세션 방식을 사용하는 이유가 무엇인가요?</summary>
  HTTP 는 무상태 프로토콜이기 때문입니다. 통신이 끝나면 사용자의 상태를 유지하지 않습니다.
</details>

---

<details>
  <summary>9. 로드밸런싱이란 무엇인가요?</summary>
  트래픽을 여러대의 서버에 분산시키는 스케일 아웃 방법입니다.
</details>
<details>
  <summary>9-1. L4, L7 로드밸런싱에 대해 설명해주세요.</summary>
  L4는 전송계층을 사용하며 IP주소나 포트번호를 기준으로 부하를 분산시키고, L7는 응용계층을 사용하며 IP주소나 포트번호 외에도 URL, 헤더, 쿠키 등으로 부하를 분산시킵니다.
</details>
<details>
  <summary>9-2. 알고계신 로드밸런싱 알고리즘에 대해 설명해주세요.</summary>
  
  - 라운드 로빈 : 요청을 순서대로 돌아가며 서버에 배정하는 방식
  - 가중 라운드 로빈 : 서버마다 가중치를 두고, 가중치가 높은 서버에 요청을 우선적으로 배분하는 방식
  - 최소 연결 방식 : 가장 적은 연결 상태를 갖은 서버에 우선적으로 배분

</details>

---

<details>
  <summary>10. HTTP란 무엇인가요?</summary>
  브라우저와 서버간에 데이터를 주고받을 수 있는 통신 규약입니다. OSI 7계층의 응용계층에 있는 프로토콜입니다.
</details>
<details>
  <summary>10-1. HTTP 1.0과 HTTP 1.1의 차이에 대해 설명해주세요.</summary>
  HTTP 1.0은 커넥션 하나 당 요청 하나와 응답 하나를 처리하여 매번 새로운 연결이 필요합니다.
  HTTP 1.1부터는 파이프라이닝이 추가되어 하나의 커넥션에서 응답을 기다리지 않고 순차적으로 여러 요청을 연속적으로 전송하고 순서대로 응답을 받을 수 있게 되었습니다.
</details>
---

<details>
  <summary>11. HTTPS와 HTTP의 차이점에 대해 설명해주세요.</summary>
    HTTPS는 기존의 HTTP에서 보안과 관련된 프로토콜이 추가된것입니다. HTTP와 TCP 사이에 클라이언트와 서버가 데이터를 암화화해서 통신할 수 있도록 하는 보안 계층인 SSL이 추가된 형태입니다.
</details>
<details>
  <summary>11-1. 대칭키 기법과 단점에 대해 설명해주세요.</summary>
  대칭키 기법는 하나의 키로 암호화와 복호화를 할 수 있는 키입니다. 공개키 암호화 방식에 비해 속도가 빠르다는 장점이 있지만 키를 교환해야한다는 문제가 있습니다. 키를 교환하는 중 키가 탈취될 위험이 존재합니다.
</details>
<details>
  <summary>11-2. 해당 단점을 해결하기 위한 비대칭키에 대해 설명해주세요.</summary>
  비대칭키 기법는 서로 다른 두 개의 키(공개키, 개인키)로 암호화, 복호화하는 기법입니다. 공개키로 암호화한 데이터는 개인키로만 복호화할 수 있고, 개인키로 암호화한 데이터는 공개키로만 복호화할 수 있습니다. 
  공개키로 암호화한 데이터를 보내면, 해당 데이터는 개인키로만 복호화할 수 있어 대칭키의 단점을 해결할 수 있습니다.
</details>

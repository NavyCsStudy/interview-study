<details>
  <summary>1. 스프링과 스프링 부트의 차이가 무엇인가요?</summary>
  
스프링 부트는 내장 톰캣, 빈 자동 구성, 스타터 의존성, 외부 설정의 추상화와 같은 기능을 통해 스프링 프레임워크를 편리하게 사용할 수 있도록 하는 프로젝트입니다.

#### 내장 톰캣
과거에는 톰캣 서버를 별도로 기동하고 WAR 파일을 배포하는 과정을 거쳐야 했으나 스프링 부트는 내장 톰캣 라이브러리를 포함하고 있습니다. 따라서 별도의 톰캣 서버를 띄울 필요 없이 스프링 부트가 제공하는 실행 가능 JAR(Excutable jar)만 실행하여 배포 할 수 있습니다.

#### 자동 구성
스프링 부트는 일반적으로 자주 사용하는 여러 빈들을 자동으로 등록해줍니다. 덕분에 개발자는 반복적이고 복잡한 빈 등록과 설정을 최소화할 수 있습니다.

#### 스타터 의존성
스프링 부트는 잘 알려진 라이브러리의 버전 정보를 관리하고 있으며 프로젝트를 시작하는 필요한 관련 라이브러리들을 모아둔 스타터 의존성을 제공합니다.

#### 외부 설정
스프링 부트는 다양한 외부 설정을 가져오는 방법을 추상화해두었습니다. 또한 `application.properties`라는 설정 파일을 통해 다양한 설정 데이터를 관리할 수 있습니다. 

</details>
<details>
  <summary>1-1. 스프링 프레임워크에 대해서 설명해줄 수 있나요?</summary>
  
스프링 프레임워크는 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크입니다. 주요한 핵심 기능은 스프링 컨테이너라고 불리는 DI 컨테이너입니다. 객체들을 스프링 빈으로 등록하면 스프링 프레임워크는 객체의 생명주기를 관리하고 의존성 주입을 통해 객체들간의 의존성을 관리합니다.
</details>
<details>
  <summary>1-2. 스프링 데이터 JPA는 JPA와 어떤 차이가 있나요?</summary>

스프링 데이터 JPA는 스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 프로젝트입니다. 주요 기능으로 공통 인터페이스, 쿼리 메서드가 있습니다.

#### 공통 인터페이스
간단한 CURD 기능을 공통으로 처리하는 `JpaRepository` 인터페이스를 제공합니다.

#### 쿼리 메서드
메서드 이름만으로 쿼리를 생성하는 기능을 가지고 있으며 메서드를 선언하면 적절한 JPQL 쿼리를 생성해서 실행해줍니다.

</details>

---

<details>
  <summary>2. 스프링의 `@Transactional`이 어떻게 작동하는지 설명해주실 수 있나요?</summary>

`@Transactional`은 스프링 AOP를 이용하여 작동합니다. 동적 프록시 기술을 이용하여 런터암에 대상 객체를 참조하는 프록시를 생성하고 이를 스프링 빈으로 등록합니다. 프록시는 커넥션 획득과 반환, 커밋과 롤백 같은 반복적인 코드를 처리해줍니다.
</details>
<details>
  <summary>2-1. `readOnly` 옵션이 `true`로 설정되어 있으면 작동 방식이 어떻게 달라지나요?</summary>

`readOnly=true` 옵션을 사용하면 읽기 전용 트랜잭션이 생성됩니다. 등록, 수정, 삭제가 불가하고 오직 읽기 기능만 작동합니다. 또한 커밋 시점에 플러시를 호출하지 않고 변경 감지를 위한 스냅샵을 저장하지 않기 때문에 성능 최적화가 발생합니다.
</details>
<details>
  <summary>2-2. 트랜잭션 AOP를 사용할 떄 주의할 점에 대해 알고 계신 것이 있나요?</summary>

프록시 객체가 참조하고 있는 실제 객체에서 내부 호출이 발생하는 경우 프록시를 거치지 않고 곧바로 실제 객체를 호출하게 됩니다. 이러한 내부 호출은 트랜잭션이 적용되지 않기 때문에 트랜잭션 AOP를 사용한다면 내부 호출에 주의해야 합니다.
</details>

---

<details>
  <summary>3. 트랜잭션 AOP를 사용했을 때 커넥션을 획득하고 사용하는 방법에 대해 설명해주실 수 있나요?</summary>

프록시는 스프링 컨테이너를 통해 트랜잭션 매니저를 획득합니다. 트랜잭션 매니저는 데이터 소스를 통해 커넥션을 획득하고 `autoCommit`을 `false`로 설정합니다. 이후 트랜잭션 동기화 매니저에 커넥션을 보관하고 필요할 때마다 해당 커넥션을 꺼내서 데이터 접근이 이루어집니다. 
</details>
<details>
  <summary>3-1. 커넥션 풀이 무엇이고 어째서 사용하는지 설명해주실 수 있나요?</summary>

애플리케이션에서 DB에 접근하기 위해 요청마다 커넥션을 생성하는 것은 비용이 많이 드는 작업입니다. 이를 해결해주는 것이 커넥션 풀입니다. 커넥션을 미리 생성해두고 필요할 때마다 꺼내 쓴 뒤 작업이 종료되면 커넥션 풀에 다시 반환합니다. 이를 통해 커넥션 생성에 드는 비용을 절감할 수 있습니다.
</details>
<details>
  <summary>3-2. ORM이 무엇인지 설명해주실 수 있나요?</summary>
  
ORM는 객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해주는 도구입니다. 

SQL이 아닌 객체 지향적인 코드를 통해서 데이터를 조작할 수 있기 때문에 개발자는 비즈니스 로직 작성에 집중할 수 있습니다.
또한 객체 간의 관계를 바탕으로 자동으로 SQL을 생성하기 때문에 DBMS에 대한 종속성이 줄어듭니다.
</details>

---

<details>
  <summary>4. MVC 패턴에 대해서 설명해주세요.</summary>

MVC 패턴은 기존 비즈니스 로직과 뷰 로직이 모두 결합된 것에서 벗어나 모델, 뷰, 컨트롤러로 역할을 나누는 패턴입니다.
</details>
<details>
  <summary>4-1. 사용자 요청이 들어오면 스프링 MVC는 어떤 과정을 거쳐 응답을 만들어주나요?</summary>

사용자 요청이 들어오면 디스패처 서블릿이 해당 요청을 받습니다. 디스패처 서블릿은 몇 가지 과정을 거쳐 사용자 요청을 처리합니다.

1. 요청 URL에 매핑된 핸들러를 조회합니다.
2. 핸들러를 실행할 수 있는 핸들러 어댑터를 조회합니다.
3. 핸들러 어댑터를 실행하면서 핸들러를 전달합니다.
4. 핸들러 어댑터가 실제 핸들러를 실행합니다.
5. 핸들러 어댑터는 핸들러가 반환하는 정보를 `ModelAndView`로 변환해서 반환합니다.
6. `ModelAndView`에 포함된 뷰 논리 이름을 물리 이름으로 바꾸기 위한 뷰 리졸버를 찾고 실행합니다.
7. 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고 렌더링을 위한 뷰 객체를 반환합니다.
8. 뷰를 렌더링합니다.
</details>
<details>
  <summary>4-2. 프론트 컨트롤러 패턴에 대해 설명해주세요.</summary>

프론트 컨트롤러 패턴은 모든 클라이언트의 요청을 처리하는 단일 컨트롤러를 두는 패턴입니다. 프론트 컨트롤러는 해당 url 요청을 처리할 적절한 컨트롤러를 호출하고, 공통의 로직을 처리합니다.
</details>
<details>
  <summary>4-3. `@RequestBody`가 파라미터에 붙어 있으면 HTTP 메시지 바디는 어떤 과정을 거쳐 변환되나요?</summary>

핸들러 어댑터는 해당 어노테이션을 처리하기 위한 `ArgumentResolver`를 호출합니다. `ArgumentResolver`는 HTTP 메시지 컨버터를 사용하여 HTTP 메시지를 처리하여 필요한 데이터를 생성합니다.
</details>

---

<details>
  <summary>5. 테스트를 많이 작성하신 것 같은데 본인이 작성한 테스트 갯수는 얼마나 되나요?</summary>

  정확한 테스트 갯수는 세어보지 않아 모르겠으나 기능 브랜치 PR 시 테스트 커버리지 70%를 만족하는 브랜치만 머지할 수 있도록 지정했었기 때문에 각 기능별로 최소 70%의 커버리지를 만족시킬 수 있을 정도로 작성하였습니다..
</details>
<details>
  <summary>5-1. API의 테스트는 어떤 방식으로 진행하셨나요?</summary>

`mockMvc`를 이용한 표현 계층 통합 테스트를 진행하였습니다. 서비스 계층의 경우 목 객체로 대체하였습니다.
</details>
<details>
  <summary>5-2. TDD와 같은 테스트 전략에 대해 알고 계시는게 있나요?</summary>

TDD는 작은 단위의 테스트 케이를 먼저 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현하는 소프트웨어 방법론입니다.
TDD의 개발 주기는 red, green, blue 세 단계로 나누어집니다.

- red: 실패하는 테스트 코드를 먼저 작성합니다.
- green: 테스트 코드를 성공시키기 위한 실제 코드를 작성합니다.
- blue: 중복 코드 제거, 일반화 등의 리팩토링을 수행합니다.

재설계 시간을 단축할 수 있고 추가 구현이 용이하다는 장점이 있습니다.

일반적인 테스트 방법보다 개발 시간이 늘어난다는 단점을 가지고 있습니다.

이 외에 ATDD라고 하여 사용자 시나리오를 기반으로 하는 ATDD가 있습니다.

</details>

---

<details>
  <summary>6. 빈 스코프에 대해 알고 있나요?</summary>

빈 스코프는 빈이 존재할 수 있는 범위를 뜻합니다. 스프링은 범위에 따라 다양한 빈 스코프를 지원합니다.
- 싱글톤: 스프링 컨테이너의 시작과 종료까지 유지되는 기본 스코프입니다.
- 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않습니다.
- 웹 스코프
  - request: 웹 요청이 들어오가 나갈때까지 유지되는 스코프입니다.
  - session: 웹 세션이 생성되고 종료될 때까지 유지되는 스코프입니다.
  - application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프입니다.
  - websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프
</details>
<details>
  <summary>6-1. 스프링 빈 생명주기 콜백에 대해 알고 있나요?</summary>

스프링은 의존관계 주입이 완료되면 스프링 빈 초기화 콜백 메서드를 호출하고, 스프링 컨테이너가 종료되기 전 소멸전 콜백 메서드를 호출합니다. 이를 통해 객체의 생성과 좀 더 무거운 초기화 작업을 분리할 수 있습니다.
</details>

---

<details>
  <summary>7. ApplicationContext의 기능에 대해 설명해주세요.</summary>

ApplicationContext는 BeanFactory를 상속하여 빈 관리기능을 기본으로 가지고 여러 부가 기능을 가집니다.
- 메시지소스를 활용한 국제화 기능
- 환경변수
- 이벤트 발행, 구독 모델을 지원하는 애플리케이션 이벤트
- 파일, 클래스패스 등 여러 리소스를 편리한 조회
가 있습니다.
</details>

---

<details>
  <summary>8. JPA의 엔티티 매니저에 대해 설명해주세요.</summary>

엔티티 매니저는 엔티티를 저장, 수정, 삭제, 조회 등 엔티티와 관련된 일을 처리하는 가상의 데이터베이스 역할을 합니다.
</details>
<details>
  <summary>8-1. 영속성 컨텍스트는 무엇인가요?</summary>

영속성 컨텍스트는 엔티티를 영구 저장하는 환경입니다. 엔티티 매니저로 저장, 조회한 엔티티는 영속성 컨텍스트에 보관하고 관리합니다.
</details>
<details>
  <summary>8-2. 영속성 컨텍스트의 특징에 대해 설명해주세요.</summary>

#### 1차 캐시와 동일성 보장

영속성 컨텍스트는 내부에 1차 캐시라 불리는 캐시를 가지며 영속 상태의 엔티티는 모두 이곳에 저장됩니다. 식별자에 해당하는 엔티티가 영속성 컨텍스트에 의해 관리되고 있다면 항상 동일한 엔티티 인스턴스를 반환합니다.

#### 트랜잭션을 지원하는 쓰기 지연

엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 isnert sql을 모아둡니다. 그리고 커밋 시점에 모아 둔 쿼리를 데이터베이스에 보냅니다.

#### 변경 감지

엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지(dirty checking)라 합니다. JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 자장해두는 데 이를 스냅샷이라 합니다. 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾습니다.
</details>

---

<details>
  <summary>9. 스프링의 트랜잭션 전파에 대해 설명해주세요.</summary>

하나의 트랜잭션 수행 중에 다른 트랜잭션 메서드를 호출하는 경우 기존에 수행되던 트랜잭션에 호출된 트랜잭션이 참여하게 됩니다. 이를 트랜잭션 전파라고 합니다.
스프링은 이러한 트랜잭션 전파에서 물리 트랜잭션, 논리 트랜잭션이라는 개념으로 나누어 하나의 논리 트랜잭션이 롤백된다면 전체 물리 트랜잭션을 롤백하게 됩니다.
</details>
<details>
  <summary>9-1. 트랜잭션 전파 옵션에 대해 설명해주세요.</summary>

#### required
스프링의 기본 트랜잭션 전파 옵션은 required입니다. required에서 진행중인 트랜잭션이 없으면 새롭게 시작하고 있으면 참여합니다.

#### required_new
required_new는 진행중인 트랜잭션에 참여하지 않고 항상 새로운 트랜잭션을 시작합니다. 개별 트랜잭션은 각각의 물리 트랜잭션을 가집니다.

#### support
진행중인 트랜잭션이 있으면 참여하고 없는 경우 트랜잭션 없이 진행됩니다.

#### not_supported
트랜잭션에 참여하거나 생성하지 않습니다.

#### mandatory
반드시 진행중인 트랜잭션이 존재해야 하며, 없으면 예외가 발생합니다.

</details>


---

<details>
<summary>10. 서블릿에 대해 설명해주세요.</summary>

서블릿이란 클라이언트의 요청에 따라 특정한 기능을 수행하고 그에 따른 응답 처리를 하는 자바 소프트웨어 컴포넌트입니다.

</details>
<details>
<summary>10-1. 서블릿 컨테이너에 대해 설명해주세요.</summary>

서블릿 컨테이너란 서블릿의 생명주기를 관리하고, URL과 특정 서블릿을 맵핑하여, URL 요청자에게 올바른 접근 권한이 있는지 확인합니다.

대표적인 예시로 톰캣(Tomcat)이 있습니다. 톰캣은 웹 서버와 통신하며 JSP, 서블릿이 실행할 수 있는 환경을 제공합니다.

#### 서블릿 생명주기

- 초기화 단계에서 서블릿 컨테이너는 `init()`을 호출하여 서블릿 인스턴스를 초기화합니다.
- 클라이언트 요청이 들어오면 WAS로부터 스레드를 획득하고 개별 스레드는 서블릿 인스턴스의 `service()`를 호출합니다. `service()`는 요청에 따른 적절한 메서드를 실행하고 응답이 만들어집니다.
- 서블릿 컨테이너는 `destroy()`를 호출하고 서블릿을 서비스에서 제거합니다.

</details>

---

<details>
<summary>11. 톰캣의 스레드 풀에 대해 설명해주세요.</summary>

사용자의 요청이 들어올때마다 스레드를 만들고 소멸하는 것은 비용이 많이 들어가는 작업입니다. 톰캣은 미리 스레드를 만들어놓은 뒤 이를 재사용하며 사용자의 요청을 처리합니다.

1. 첫 작업이 들어오면, core size만큼의 스레드를 생성합니다.
2. 유저 요청이 들어올 때마다 작업 큐에 담아둡니다.
3. core size의 스레드 중, 유휴상태(idle)인 스레드가 있다면 작업 큐에서 작업을 꺼내 스레드에 할당합니다.
  - 유휴상태인 스레드가 없다면, 작업은 작업 큐에서 대기합니다.
  - 작업 큐가 가득 차면, 스레드를 새로 생성합니다.
  - 생성할 수 있는 최대 스레드 사이즈에 도달하면, 추가 요청에 대해 connection-refused 오류를 반환합니다.
4. 작업이 완료되면 스레드는 다시 유휴상태로 돌아갑니다.
  - 작업 큐가 비어있고 core size 이상의 스레드가 생성되어있다면 스레드를 destroy 합니다.

톰캣의 스레드 풀과 관련된 스프링 부트의 기본 설정 값은 다음과 같습니다.
```yml
server:
  tomcat:
    threads:
      max: 200  # 생성할 수 있는 스레드의 총 개수
      min-spare: 10  # 항상 활성화되어 있는 스레드의 개수
    max-connections: 8192  # 동시에 처리할 수 있는 Connection의 개수
    accept-count: 100  # max-connections 이상의 요청이 들어왔을 때 사용하는 요청 대기열의 사이즈
```

톰캣의 Non-Blocking IO 에서는 스레드 풀의 최대 스레드 개수보다 많은 양의 Connection을 유지할 수 있습니다. NIO에서 최대 스레드 개수보다 적거나 같은 수의 max-connections를 설정하는 것은 비효율적인 설정이 될 수 있습니다.

</details>

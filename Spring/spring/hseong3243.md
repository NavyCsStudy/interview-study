<details>
  <summary>1. 스프링과 스프링 부트의 차이가 무엇인가요?</summary>
  
스프링 부트는 내장 톰캣, 빈 자동 구성, 스타터 의존성, 외부 설정의 추상화와 같은 기능을 통해 스프링 프레임워크를 편리하게 사용할 수 있도록 하는 프로젝트입니다.

#### 내장 톰캣
과거에는 톰캣 서버를 별도로 기동하고 WAR 파일을 배포하는 과정을 거쳐야 했으나 스프링 부트는 내장 톰캣 라이브러리를 포함하고 있습니다. 따라서 별도의 톰캣 서버를 띄울 필요 없이 스프링 부트가 제공하는 실행 가능 JAR(Excutable jar)만 실행하여 배포 할 수 있습니다.

#### 자동 구성
스프링 부트는 일반적으로 자주 사용하는 여러 빈들을 자동으로 등록해줍니다. 덕분에 개발자는 반복적이고 복잡한 빈 등록과 설정을 최소화할 수 있습니다.

#### 스타터 의존성
스프링 부트는 잘 알려진 라이브러리의 버전 정보를 관리하고 있으며 프로젝트를 시작하는 필요한 관련 라이브러리들을 모아둔 스타터 의존성을 제공합니다.

#### 외부 설정
스프링 부트는 다양한 외부 설정을 가져오는 방법을 추상화해두었습니다. 또한 `application.properties`라는 설정 파일을 통해 다양한 설정 데이터를 관리할 수 있습니다. 

</details>
<details>
  <summary>1-1. 스프링 프레임워크에 대해서 설명해줄 수 있나요?</summary>
  
스프링 프레임워크는 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크입니다. 주요한 핵심 기능은 스프링 컨테이너라고 불리는 DI 컨테이너입니다. 객체들을 스프링 빈으로 등록하면 스프링 프레임워크는 객체의 생명주기를 관리하고 의존성 주입을 통해 객체들간의 의존성을 관리합니다.
</details>
<details>
  <summary>1-2. 스프링 데이터 JPA는 JPA와 어떤 차이가 있나요?</summary>

스프링 데이터 JPA는 스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 프로젝트입니다. 주요 기능으로 공통 인터페이스, 쿼리 메서드가 있습니다.

#### 공통 인터페이스
간단한 CURD 기능을 공통으로 처리하는 `JpaRepository` 인터페이스를 제공합니다.

#### 쿼리 메서드
메서드 이름만으로 쿼리를 생성하는 기능을 가지고 있으며 메서드를 선언하면 적절한 JPQL 쿼리를 생성해서 실행해줍니다.

</details>

---

<details>
  <summary>2. 스프링의 `@Transactional`이 어떻게 작동하는지 설명해주실 수 있나요?</summary>

`@Transactional`은 스프링 AOP를 이용하여 작동합니다. 동적 프록시 기술을 이용하여 런터암에 대상 객체를 참조하는 프록시를 생성하고 이를 스프링 빈으로 등록합니다. 프록시는 커넥션 획득과 반환, 커밋과 롤백 같은 반복적인 코드를 처리해줍니다.
</details>
<details>
  <summary>2-1. `readOnly` 옵션이 `true`로 설정되어 있으면 작동 방식이 어떻게 달라지나요?</summary>

`readOnly=true` 옵션을 사용하면 읽기 전용 트랜잭션이 생성됩니다. 등록, 수정, 삭제가 불가하고 오직 읽기 기능만 작동합니다. 또한 커밋 시점에 플러시를 호출하지 않고 변경 감지를 위한 스냅샵을 저장하지 않기 때문에 성능 최적화가 발생합니다.
</details>
<details>
  <summary>2-2. 트랜잭션 AOP를 사용할 떄 주의할 점에 대해 알고 계신 것이 있나요?</summary>

프록시 객체가 참조하고 있는 실제 객체에서 내부 호출이 발생하는 경우 프록시를 거치지 않고 곧바로 실제 객체를 호출하게 됩니다. 이러한 내부 호출은 트랜잭션이 적용되지 않기 때문에 트랜잭션 AOP를 사용한다면 내부 호출에 주의해야 합니다.
</details>

---

<details>
  <summary>3. 트랜잭션 AOP를 사용했을 때 커넥션을 획득하고 사용하는 방법에 대해 설명해주실 수 있나요?</summary>

프록시는 스프링 컨테이너를 통해 트랜잭션 매니저를 획득합니다. 트랜잭션 매니저는 데이터 소스를 통해 커넥션을 획득하고 `autoCommit`을 `false`로 설정합니다. 이후 트랜잭션 동기화 매니저에 커넥션을 보관하고 필요할 때마다 해당 커넥션을 꺼내서 데이터 접근이 이루어집니다. 
</details>
<details>
  <summary>3-1. 커넥션 풀이 무엇이고 어째서 사용하는지 설명해주실 수 있나요?</summary>

애플리케이션에서 DB에 접근하기 위해 요청마다 커넥션을 생성하는 것은 비용이 많이 드는 작업입니다. 이를 해결해주는 것이 커넥션 풀입니다. 커넥션을 미리 생성해두고 필요할 때마다 꺼내 쓴 뒤 작업이 종료되면 커넥션 풀에 다시 반환합니다. 이를 통해 커넥션 생성에 드는 비용을 절감할 수 있습니다.
</details>
<details>
  <summary>3-2. ORM이 무엇인지 설명해주실 수 있나요?</summary>
  
ORM는 객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해주는 도구입니다. 

SQL이 아닌 객체 지향적인 코드를 통해서 데이터를 조작할 수 있기 때문에 개발자는 비즈니스 로직 작성에 집중할 수 있습니다.
또한 객체 간의 관계를 바탕으로 자동으로 SQL을 생성하기 때문에 DBMS에 대한 종속성이 줄어듭니다.
</details>

---

<details>
  <summary>4. MVC 패턴에 대해서 설명해주세요.</summary>

MVC 패턴은 기존 비즈니스 로직과 뷰 로직이 모두 결합된 것에서 벗어나 모델, 뷰, 컨트롤러로 역할을 나누는 패턴입니다.
</details>
<details>
  <summary>4-1. 사용자 요청이 들어오면 스프링 MVC는 어떤 과정을 거쳐 응답을 만들어주나요?</summary>

사용자 요청이 들어오면 디스패처 서블릿이 해당 요청을 받습니다. 디스패처 서블릿은 몇 가지 과정을 거쳐 사용자 요청을 처리합니다.

1. 요청 URL에 매핑된 핸들러를 조회합니다.
2. 핸들러를 실행할 수 있는 핸들러 어댑터를 조회합니다.
3. 핸들러 어댑터를 실행하면서 핸들러를 전달합니다.
4. 핸들러 어댑터가 실제 핸들러를 실행합니다.
5. 핸들러 어댑터는 핸들러가 반환하는 정보를 `ModelAndView`로 변환해서 반환합니다.
6. `ModelAndView`에 포함된 뷰 논리 이름을 물리 이름으로 바꾸기 위한 뷰 리졸버를 찾고 실행합니다.
7. 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고 렌더링을 위한 뷰 객체를 반환합니다.
8. 뷰를 렌더링합니다.

</details>
<details>
  <summary>4-2. `@RequestBody`가 파라미터에 붙어 있으면 HTTP 메시지 바디는 어떤 과정을 거쳐 변환되나요?</summary>

핸들러 어댑터는 해당 어노테이션을 처리하기 위한 `ArgumentResolver`를 호출합니다. `ArgumentResolver`는 HTTP 메시지 컨버터를 사용하여 HTTP 메시지를 처리하여 요청 데이터를 생성합니다. 
</details>

---

<details>
  <summary>5. 테스트를 많이 작성하신 것 같은데 본인이 작성한 테스트 갯수는 얼마나 되나요?</summary>

  정확한 테스트 갯수는 세어보지 않아 모르겠으나 기능 브랜치 PR 시 테스트 커버리지 70%를 만족하는 브랜치만 머지할 수 있도록 지정했었기 때문에 각 기능별로 최소 70%의 커버리지를 만족시킬 수 있을 정도로 작성하였습니다..
</details>
<details>
  <summary>5-1. API의 테스트는 어떤 방식으로 진행하셨나요?</summary>

`mockMvc`를 이용한 표현 계층 통합 테스트를 진행하였습니다. 서비스 계층의 경우 목 객체로 대체하였습니다.
</details>
<details>
  <summary>5-2. TDD와 같은 테스트 전략에 대해 알고 계시는게 있나요?</summary>

TDD는 작은 단위의 테스트 케이를 먼저 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현하는 소프트웨어 방법론입니다.
TDD의 개발 주기는 red, green, blue 세 단계로 나누어집니다.

- red: 실패하는 테스트 코드를 먼저 작성합니다.
- green: 테스트 코드를 성공시키기 위한 실제 코드를 작성합니다.
- blue: 중복 코드 제거, 일반화 등의 리팩토링을 수행합니다.

재설계 시간을 단축할 수 있고 추가 구현이 용이하다는 장점이 있습니다.

일반적인 테스트 방법보다 개발 시간이 늘어난다는 단점을 가지고 있습니다.

이 외에 ATDD라고 하여 사용자 시나리오를 기반으로 하는 ATDD가 있습니다.

</details>

---

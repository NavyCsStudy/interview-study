<details>
  <summary>1. 서블릿이 무엇인지 설명해주세요.</summary>
  서블릿은 자바 기반의 웹 애플리케이션 프로그래밍 기술로, 동적 웹페이지를 만들 때 사용됩니다. 웹을 구성하는 다양한 요청(requests)과 응답(responses)이 있으며, 이러한 요청과 응답에는 규칙이 존재합니다. 서블릿은 이러한 요청과 응답을 일일히 처리하지 않고, 간단한 메서드 호출을 통해 웹 요청과 응답의 흐름을 체계적으로 다룰 수 있게 해줍니다. 서블릿을 사용하면 웹 애플리케이션을 효율적으로 개발하고 관리할 수 있습니다.
</details>
<details>
  <summary>1-1. 서블릿 컨테이너가 무엇인지 설명해주시고 주요 기능에 대해서 설명해주세요</summary>
  서블릿 컨테이너는 클라이언트의 요청을 받아주고 응답할 수 있게, 웹서버와 소켓으로 통신하며 대표적인 예로 아파치 톰캣(Tomcat)이 있습니다.<br>
1. 서블릿 컨테이너는 서블릿과 웹서버가 손쉽게 통신할 수 있게 해줍니다. 네트워크를 통한 소통을 위해서는 소켓을 만들고 listen, accept, connect 등을 해야하지만 서블릿 컨테이너는 이러한 기능을 API로 제공하여 간편화합니다. 결과적으로 개발자는 서블릿에 구현해야 할 비지니스 로직에 대해서만 초점을 두게끔 도와줍니다.<br>
2. 서블릿의 생명주기를 관리합니다. <br>
3. 멀티쓰레드를 지원 및 관리합니다. <br>
4. 선언적 보안 관리
</details>
<details>
  <summary>1-2. 서블릿 컨테이너의 동작과정에 대해서 간단하게 설명해주세요.</summary>
  <li> 앞서 클라이언트의 요청이 들어오면 서블릿 컨테이너는 해당 web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다. 해당 서블릿이 메모리에 없을 경우 init()을 통해 생성하고, 서블릿이 변경되었을 경우 파괴 후 init()을 통해 새로운 내용을 적재합니다.</li>
<li> 서블릿이 있는 경우 service() 메소드를 통해 요청에 대한 응답이 doGet(), doPost()로 나뉘어 response가 생성됩니다.</li>
<li> 컨테이너가 서블릿을 종료시킬때에는 destroy()를 통해 종료됩니다.</li>
</details>
<details>
  <summary>1-3. 서블릿의 생명주기에 대해서 아시는대로 설명해주세요.</summary>
  1. 요청이 오면, Servlet 클래스가 로딩되어 요청에 대한 Servlet 객체가 생성됩니다.<br>
2. 서버는 init() 메소드를 호출해서 Servlet을 초기화합니다.<br>
3. service() 메소드를 호출해서 Servlet이 브라우저의 요청을 처리하도록 합니다.<br>
4. service() 메소드는 특정 HTTP 요청(GET, POST 등)을 처리하는 메서드 (doGet(), doPost() 등)를 호출합니다.<br>
5. 서버는 destroy() 메소드를 호출하여 Servlet을 제거합니다.
</details>
<details>
  <summary>1-4. Dispatcher-Servlet이란</summary>
  서블릿 컨테이너에서 HTTP 프로토콜을 통해 들어오는 모든 요청을 제일 앞에서 처리해주는 프론트 컨트롤러를 말함

따라서 서버가 받기 전에, 공통처리 작업을 디스패처 서블릿이 처리해주고 적절한 세부 컨트롤러로 작업을 위임해줍니다.

디스패처 서블릿이 처리하는 url 패턴을 지정해줘야 하는데, 일반적으로는 .mvc와 같은 패턴으로 처리하라고 미리 지정해줍니다.

디스패처 서블릿으로 인해 web.xml이 가진 역할이 상당히 축소되었습니다. 기존에는 모든 서블릿을 url 매핑 활용을 위해 모두 web.xml에 등록해 주었지만, 디스패처 서블릿은 그 전에 모든 요청을 핸들링해주면서 작업을 편리하게 할 수 있도록 도와줍니다. 또한 이 서블릿을 통해 MVC를 사용할 수 있기 때문에 웹 개발 시 큰 장점을 가져다 줍니다.
</details>

---

<details>
  <summary>2. Spring의 특징</summary>
  대표적으로 DI/IoC, AOP 가 있습니다.
</details>
<details>
  <summary>2-1. Spring DI/IoC는 어떻게 동작하나요?</summary>
  IoC(제어의 역전)은 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것으로 코드의 최종호출은 개발자가 제어하는 것이 아닌 프레임워크의 내부에서 결정된 대로 이루어집니다.

DI(의존성 주입)은 Spring 프레임워크에서 지원하는 IoC의 형태로 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해줍니다.
</details>
<details>
  <summary>2-2. DI 종류는 어떤 것들이 있나요?</summary>
  setter 메서드를 통해 의존 관계를 주입하는 수정자 주입 방법,

생성자를 통해 주입하는 생성자 주입 방법,

필드에 @Autowired를 붙여서 바로 주입하는 필드 주입 방법이 있습니다.
</details>
<details>
  <summary>2-3. Spring AOP에 대해서 설명해주세요.</summary>
  관점 지향 프로그래밍으로 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하는 것입니다.

공통의 관심 사항을 적용해서 발생하는 의존 관계의 복잡성과 코드 중복을 해소해줍니다.

각 클래스에서 공통 관심 사항을 구현한 모듈에 대한 의존관계를 갖기 보단, Aspect를 이용해 핵심 로직을 구현한 각 클래스에 공통 기능을 적용합니다.

간단한 설정만으로도 공통 기능을 여러 클래스에 적용할 수 있는 장점이 있으며 핵심 로직 코드를 수정하지 않고도 웹 애플리케이션의 보안, 로깅, 트랜잭션과 같은 공통 관심 사항을 AOP를 이용해 간단하게 적용할 수 있습니다.
</details>

---

<details>
  <summary>3. DAO, DTO, VO에 대해서 설명해주세요.</summary>
  DAO는 Data Access Object로 주로 DB의 data에 접근하기 위한 객체입니다.

DTO는 Data Transfer Object로 레이어간 데이터를 전송하기 위해 정의된 객체입니다. 주로 json과 같은 직렬화에 사용되는 객체입니다.

VO는 DTO와 유사하지만 DTO와 달리 Read-Only라는 속성을 가지고 있는 객체입니다.
</details>

---

<details>
  <summary>4. IoC Container란?</summary>
  스프링에서 객체를 생성하고 관리하고 책임지고 의존성을 관리해주는 컨테이너를 말합니다.
</details>
<details>
  <summary>4-1. IoC Container의 종류에는 무엇이 있고, 차이점</summary>
  <li> BeanFactory<ul>
    <li> 단순히 컨테이너에서 객체를 생성하고 DI를 처리하는 기능만 제공</li>
    <li> Bean을 등록, 생성, 조회, 반환</li>
    <li> 팩토리 디자인 패턴을 구현한 것으로 빈을 생성하고 분배하는 책임을 가짐</li></ul></li>
<li> ApplicationContext (= IoC Container라고 볼 수 있음)<ul>
    <li> Bean을 등록, 생성, 조회, 반환 관리하는 기능은 BeanFactory와 같다.</li>
    <li> 스프링의 각종 부가 기능을 추가로 제공<ul>
        <li> 국제화가 지원되는 텍스트 메세지를 관리</li>
        <li> 이미지 같은 파일 자원을 로드할 수 있는 포괄적인 방법을 제공</li>
        <li> 리스너로 등록된 빈에게 이벤트 발생을 알려줌</li></ul></li></ul></li>
</details>

---

<details>
  <summary>5. VO와 DTO, DAO에 대해서 간단하게 설명해주세요.</summary>
  DAO는 Data Access Object로 주로 DB의 data에 접근하기 위한 객체입니다.<br>
DTO는 Data Transfer Object로 레이어간 데이터를 전송하기 위해 정의된 객체입니다. 주로 json과 같은 직렬화에 사용되는 객체입니다.<br>
VO는 DTO와 유사하지만 DTO와 달리 Read-Only라는 속성을 가지고 있는 객체입니다.
</details>
<details>
  <summary>5-1. VO를 사용해보신적이 있으신지 있다면 어느 상황에서 사용해보셨는지 알려주세요.</summary>
  
</details>
<details>
  <summary>5-2. VO를 사용하셨을 때의 이점은 무엇이 있었나요?</summary>
  VO는 도메인에서 한 개 또는 그 이상의 속성들을 묶어서 특정 값을 나타낼 때 사용합니다.<br>
원시타입으로 도메인 객체를 모델링 했을 때의 한계를 극복해줍니다.<br>
예를 들어서 돈의 타입을 int 대신 Money라는 객체로 정의한다면, 의미를 명확히 드러낼 수 있을 뿐더러 돈의 값이 0이상인 양수를 보장해주는 등 제약사항을 추가할 수도 있습니다.<br>
또한 원시값들을 VO로 포장하면 엔티티가 지나치게 커지는 것을 막을 수 있습니다.
</details>

---

<details>
  <summary>6. 수동으로 빈을 등록하는 방법과 자동으로 등록하는 방법에 대해 설명해주세요.</summary>
  수동으로 등록하는 방법은 @Configuration 애너테이션이 붙은 클래스에서 @Bean 애너테이션이 붙은 메서드 반환값을 등록합니다. 또는 xml 파일을 이용할 수도 있습니다.<br>
자동으로 등록하는 방법은 @Component 애너테이션 혹은 @Component 기반 애너테이션들은 컴포넌트 스캔을 통해 자동으로 빈으로 등록됩니다.
</details>
<details>
  <summary>6-1. 언제 수동으로 빈을 등록하면 좋을까요?</summary>
  데이터베이스 연결이나 공통 로그 처리와 같은 기술 적인 문제나 공통 관심사를 처리할 때 수동으로 빈을 등록하여 설정 정보에 명확하게 나타나게 하는 것이 유지보수에 좋다고 합니다. (문제 발생했을 때 위치 파악 쉬움)<br>
또한 비즈니스 로직 중 다형성을 적극 활용하는 빈에 대해 사용하면 좋습니다.
</details>

---

<details>
  <summary>7. 동적 프록시에 대해 설명해주세요. </summary>
  정적 프록시가 가진 문제를 해결하고자 런타임 시점에 프록시를 자동으로 만들어서 적용해주는 기술입니다.
</details>
<details>
  <summary>7-1. JDK Dynamic Proxy와 CGLIB의 차이점은 무엇인가요?</summary>
  <li> JDK 동적 프록시<ul>
    <li> 인터페이스 기반으로 프록시를 생성한다.</li>
    <li> 개발자가 직접 일일이 프록시 객체를 생성하는 것이 아닌, 프록시 패키지에서 제공하는 API를 이용하여 동적으로 프록시 인스턴스를 만들어 등록하는 방법 👉 Reflection API 기법을 응용한 연장선의 개념</li></ul></li>
<li> CGLIB<ul>
    <li> 클래스 기반(인터페이스도 가능)**으로 프록시를 생성한다.</li>
    <li> 바이트코드를 조작해 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리</il></ul></li>
</details>

---

<details>
  <summary>8. JDBC, SpringJDBC, JdbcTemplate에 대해서 설명해주세요</summary>
  JDBC는 자바와 데이터베이스를 연결하기 위한 Java 표준 인터페이스이며, SpringJDBC는 스프링에서 DB를 사용하기 위한 오리지널 의존성입니다.<br>
JdbcTemplate은  SpringJDBC에서 제공하는 클래스로 개발자가 JDBC 기술을 쉽게 사용할 수 있도 도와줍니다.
</details>

---

<details>
  <summary>9. 영속성 컨텍스트란?</summary>
  엔티티를 영구 저장하는 환경이라는 뜻으로, 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 역할을 수행합니다. EntityManager에  엔티티를 저장하거나 조회하면 EntityManager는 영속성 컨텍스트에 엔티티를 보관하고 관리합니다.<br>
해당 트렌잭션이 끝날 때(commit) 그 동안 모아둔 쿼리를 DB에 쏴주게 된다. 여기서 중요한 것은 영속성 컨텍스트는 당연히 하나의 트렌젝션에서만 공유가 된다.
</details>
<details>
  <summary>9-1. 영속성 컨텍스트의 구조에 대해서 설명해주세요</summary>
  영속성 컨텍스트의 내부구조에는 SQL을 저장하는 저장공간과 객체들을 저장하는 공간이 있습니다.<br>
SQL 저장공간에는 DB에 날려주어야 하는 쿼리들을 저장해두고 있습니다. 그리고 영속성 컨텍스트로 관리되고 있는 객체에 대한 정보를 저장해 둡니다. <br>
이때 스냅샷은 최초 객체가 생성될 때의 상태를 저장해두며 이것을 저장하는 이유는 추후 Dirty Check를 위해서입니다.
</details>
<details>
  <summary>9-2. 영속성 컨텍스트의 장점</summary>
  1. 영속성 컨텍스트 안에서는 엔티티의 동일성을 보장합니다.<br>
2. 트랜잭션을 커밋하기 직전까지 쓰기 쿼리들을 모아둡니다.<br>
3. 변경 감지 기능이 제공되어 JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터를 변경하면 됩니다.
</details>
<details>
  <summary>9-3. 영속성 컨텍스트 중 flush()에 대해서 설명해주세요 그리고 commit()과 어떤 차이가 있는지 설명해주세요</summary>
  영속성 컨텍스트의 변경 내용을 데이터베이스에 반영합니다.<br>
flush()의 역할로는<br>

1. 수정된 엔티티 있으면 UPDATE 쿼리 쓰기 지연 SQL 저장소에 쌓아두는 엔티티 변경 감지를 수행하고,
2. 쌓아둔 쓰기 지연 SQL 쿼리를 DB에 전송합니다.
3. flush 이후 영속성 컨텍스트를 비우진 않습니다.

이때 commit()을 하게 되면 flush()가 자동 호출된다고 합니다. commit을 호출하면 DB에 번경사항이 영구적으로 반영된 후 영속성 컨텍스트를 제거한다고 합니다. 하지만 flush는 트랜잭션이 종료된 것이 아니기 때문에 롤백이 가능하고 영속성 컨텍스트도 존재합니다.
</details>
<details>
  <summary>9-4. 준영속 엔티티를 수정하는 방법에 대해서 설명해주세요</summary>
  준영속엔티티란 영속성 엔티티의 관리를 받고 있지 않은 엔티티를 의미하며 변경 감지, 병합을 통해 수정할 수 있습니다.<br>
변경 감지는 영속성 컨테스트에서 해당 id를 다시 조회하여 영속상태로 만든 뒤 수정하여 변경감지 기능을 사용하는 것이고,<br>
merge() 메소드는 준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환하는 방식입니다.
</details>

---

<details>
  <summary>10. 즉시 로딩과 지연 로딩에 대해 설명해주실 수 있나요?</summary>
  즉시 로딩은 엔티티를 로드할 때, 관련된 모든 연관 엔티티나 컬렉션도 함께 즉시 로드하는 전략입니다.<br>
지연 로딩은 엔티티를 로드할 때, 연관된 엔티티나 컬렉션을 실제로 사용할 때 까지 로드하지 않는 전략입니다.
</details>
<details>
  <summary>10-1. 어떤 상황에서 각 로딩 방식을 사용하면 좋을까요?</summary>
  지연 로딩을 주로 사용하고 해당 엔티티의 연관된 엔티티를 항상 조회해야 하는 경우에는 즉시 로딩을 사용하는 것이 좋다고 합니다. N + 1 문제가 발생할 수 있기 때문.
</details>

---
<details>
  <summary>11. 단위테스트, 통합테스트, 인수테스트에 대해서 설명해주세요</summary>
  단위테스트는 함수, 메소드 또는 클래스와 같은 작은 코드 조각을 대상으로 하며 주로 개별 코드 유닛의 기능과 동작을 검증하고 코드의 작은 부분들이 예상대로 작동하는지 확인합니다.<br>
통합테스트는 다양한 코드 유닛이 함께 작동할 때의 상호 작용을 검증합니다. 단위 테스트에서는 확인할 수 없는 코드 유닛 간의 상호 작용 및 연동을 테스트하여 시스템이 정상적으로 통합되었는지 확인합니다.<br>
인수테스트는 소프트웨어를 최종 사용자 또는 고객의 요구 사항에 따라 테스트하며 시스템이 실제 환경에서 사용 가능하며 고객 요구 사항을 충족하는지 확인합니다.
</details>
<details>
  <summary>11-1. stub, mock은 어떠한 차이점이 존재하나요?</summary>
  stub과 mock 모두 모의 객체입니다.

stub은 더미 객체를 생성하고 실제로 동작하는것처럼 보이게 만든 가짜 객체입니다. 메서드 수행 후 객체의 상태를 확인하여 올바르게 동작했는지를 확인하는 상태 검증 방법입니다. 테스트에서 호출된 요청에 대해 미리 준비해둔 답변을 응답하며 협력 객체의 특정 부분이 테스트가 어려운 경우, stub을 사용하여 수월하게 테스트할 수 있습니다.

mock은 호출에 대한 기대를 명세하고, 내용에 따라 동작하도록 프로그래밍 된 객체입니다. 행위 검증으로 특정 동작을 수행하는지(= 메소드를 제대로 콜 하는지)에 대한 검증을 할 수 있습니다. 테스트 작성을 위한 환경 구축이 어려울 때, 테스트하고자 하는 코드와 엮인 객체들을 대신하기 위해 만들어진 객체입니다.
</details>

---
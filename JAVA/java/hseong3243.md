<details>
  <summary>1. JDK, JRE, JVM의 차이가 무엇인가요?</summary>
  
    jdk는 자바 개발 시 필요한 라이브러리들과 개발 도구들이 포함되어 있는 개발 키트입니다. 자바 프로그램의 실행을 위해 jre를 포함합니다.
    jre는 jvm과 자바 프로그램을 실행시킬 때 필요한 라이브러리 api를 함께 묶어서 배포하는 패키지입니다.
    jvm은 컴퓨터 상에서 Java 바이트코드로 컴파일 된 프로그램을 실행할 수 있도록 해주는 가상 머신입니다.
</details>
<details>
  <summary>1-1. JVM의 구성요소는 어떻게 되나요?</summary>
  
jvm은 클래스 로더, 런타임 데이터 영역, 실행 엔진으로 구성되어 있습니다.

#### 클래스 로더
클래스 로더는 런타임 중에 클래스를 JVM에 동적으로 로드하는 역할을 담당합니다. 런타임에 클래스가 필요할 때 JRE가 클래스 로더를 호출하고 클래스 로더가 JVM에 메모리를 로드합니다.

#### 실행 엔진
실행 엔지는 클래스 파일을 실행하는 역할을 담당합니다. 인터프리터, 짓 컴파일러, 가비지 컬렉터로 구성되어 있습니다.

#### 런타임 데이터 영역
런타임 데이터 영역은 PC 레지스터, 스택 영역, 힙 영역, 메서드 영역, 네이티브 메서드 스택으로 구성되어 있습니다.

##### PC 레지스터
jvm에서 실행되는 각각의 스레드는 자체 PC 레지스터를 가지며 현재 실행중인 명령어 주소를 저장합니다.

##### 스택 영역
각각의 스레드는 생명주기를 함께하는 JVM 스택을 가집니다. JVM 스택은 메서드가 호출될 때마다 새롭게 생성되는 프레임을 가지고 있습니다. 프레임에는 지역 변수, 중간 연산 결과, 메서드 호출 및 반환 정보 등이 포함되어 있습니다.

##### 힙 영역
힙 영역은 모든 jvm 스레드가 공유하는 영역으로 객체 및 배열의 메모리가 할당되는 영역입니다. 힙은 jvm의 생명주기와 함께하며 힙에 생성된 객체는 가비티 컬렉터라고 불리는 저장소 관리 시스템에 의해 회수됩니다.

##### 메서드 영역
메서드 영역은 JVM 스레드가 공유하는 영역으로 프로그램을 실행하는데 필요한 공통 데이터를 관리합니다. 포함되는 데이터로는
**클래스 정보**
- 클래스의 바이트 코드, 필드, 메서드와 생성자 등 모든 실행 코드가 존재합니다.

**static 영역**
- static 변수들을 보관합니다.

**런타임 상수 풀**
- 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관합니다.

##### 네이티브 메서드 스택
자바가 아닌 다른 언어로 작성된 메서드를 사용하기 위해 C스택이라고 하는 기존 스택을 사용할 수 있습니다.
</details>
<details>
  <summary>1-2. 가비지 컬렉터의 작동 방식에 대해 설명해주세요.</summary>
  
가비지 컬렉터는 힙 영역에 할당했던 메모리 중 더 이상 참조되지 않는 객체를 모아 주기적으로 제거합니다.
GC는 힙의 young 영역에서 일어나는 minor GC와 old 영역에서 일어나는 메이저 GC로 나뉩니다.

##### Minor GC

모든 객체는 처음에 young 영역의 eden 영역에 위치합니다. eden 영역이 가득 차면 minor GC가 실행됩니다. Mark and Sweep이라는 과정을 거쳐 참조되지 않는 객체의 메모리는 해제되고서 살아남은 객체는 survivor 영역으로 이동합니다. 다시 eden 영역이 가득차면 앞선 과정이 반복되며 살아남은 객체는 비어있는 survivor 영역으로 번갈아나가면서 이동하게 됩니다.

##### Major GC

young 영역에서 충분히 오래 살아남은 객체는 old 영역으로 이동하게 되고 old 영역이 가득차면 Major GC가 실행됩니다. old 영역은 young 영역에 비해 큰 메모리 공간을 가지고 있기 때문에 minor GC에 비해 긴 시간이 소요됩니다.
</details>

---

<details>
  <summary>2. 객체 지향이란 무엇인가요?</summary>

객체 지향이란 상태와 행위를 가진 객체들의 상호 협력을 통해 하나의 프로그램을 구성하는 프로그래밍 패러다임입니다.

##### 객체 지향의 장점
클래스 단위로 모듈화시켜서 개발 하기 때문에 대규모 소프트웨어 개발에 적합합니다.
클래스 단위로 수정이 가능하기 때문에 유지 보수가 편리합니다.
변경에 유연하게 대응할 수 있습니다.

##### 객체 지향의 단점
설계시 많은 노력이 필요합니다.
절차 지향에 비해 상대적으로 처리 속도가 느립니다.
</details>
<details>
  <summary>2-1. 객체 지향의 특성에 관해 설명해주세요.</summary>
  
객체 지향의 특성은 캡슐화, 추상화, 다형성, 상속이 있습니다.

##### 캡슐화

캡슐화는 객체의 로직을 내부로 숨겨서 클라이언트가 알지 못하도록 하는 것을 말합니다.

##### 추상화

추상화는 클라이언트에게 객체의 세부적인 처리 내용을 알리지 않고 어떤 역할을 하는지만 추상적으로 알리는 것을 말합니다.

##### 다형성

다형성은 동일한 메시지를 이해할 수 있는 어떤 객체가 와도 협력할 수 있는 것을 말합니다.

##### 상속

상속은 부모 클래스의 기능을 자식 클래스에 물려주면서 동일한 메시지를 이해할 수 있는 타입 계층을 형성하는 것입니다.

이러한 객체 지향의 4대 특성을 통해 객체의 응집도는 높이고 외부와의 결합도는 낮추며 각각의 객체의 로직은 자유롭게 발전해나가며 변경에 유연하게 대응할 수 있습니다.
</details>
<details>
  <summary>2-2. 객체 지향의 설계 원칙에 대해 설명해주세요.</summary>
  
객체 지향 설계 원칙은 줄여서 SOLID라고 말하는 5가치 원칙으로 구성되어 있습니다.

##### 단일 책임 원칙

어떠한 모듈이 변경된다면 그 이유는 오직 하나뿐이어야 한다는 것입니다.

##### 개방-폐쇄 원칙

소프트웨어 개체는 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 합니다.

##### 리스코프 치환 원칙

상위 타입의 객체가 할 수 있는 일은 어떤 하위 타입의 객체가 와도 할 수 있어야 합니다.

##### 인터페이스 분리 원칙

모든 일을 처리하는 하나의 슈퍼 클래스보다 여러 개의 분리된 인터페이스를 의존해야 합니다.

##### 의존성 역전 원칙

변동성이 큰 구현체가 아닌 안정된 추상 인터페이스를 의존해야 합니다.
</details>

---

<details>
  <summary>3. 자바 예외의 계층 구조에 대해 설명해주세요.</summary>
  
자바의 다른 모든 객체처럼 예외 역시 최상위에 Object를 두고 있으며 그 하위에 최상위 예외인 Throwable이 있습니다. Throwable의 하위에는 Exception과 Error가 있습니다. Error는 메모리 부족과 같은 애플리케이션에서 복구 불가능한 시스템 오류가 속하며 이외에 개발자의 실수록 발생하며 애플리케이션에서 처리할 수 있는 오류인 Exception이 있습니다.
</details>
<details>
  <summary>3-1. 체크 예외와 언체크 예외의 차이가 무엇인가요?</summary>

##### 체크 예외

체크 예외는 컴파일러가 체크하는 예외입니다. 이는 개발자가 잡아서 처리하거나 명시적으로 메서드를 호출한 곳으로 던지게 됩니다. 만일 어떠한 곳에서도 예외를 잡아서 처리하지 않고 `main()`까지 가면 예외 로그를 출력하면서 시스템이 종료됩니다. 

##### 언체크 예외

언체크 예외는 컴파일러가 체크하지 않는 에외입니다. 개발자가 잡아서 처리할 수도 있지만 처리하지 않는 경우 별도로 `throws`를 선언하지 않고 생략할 수 있습니다.
</details>
<details>
  <summary>3-2. 체크 예외와 언체크 예외의 장단점에 대해 설명해주세요.</summary>

##### 체크 예외 장단점

체크 예외는 컴파일러가 체크하기 때문에 개발자가 실수로 예외를 누락하지 않도록 도와줍니다. 반면 개발자가 크게 신경쓰고 싶지 않은 예외까지 모두 챙겨야 하며 명시적으로 던지는 과정에서 예외 발생 지점부터 해당 예외를 잡아서 처리하는 부분까지 해당 예외에 대한 의존관계가 발생합니다. 해당 예외를 발생시키는 기술이 변경된다면 모든 게층에 걸쳐 예외의 파급 효과가 발생할 수 있습니다.

##### 언체크 예외 장단점

언체크 예외는 컴파일러가 체크하지 않기 때문에 크게 신경쓰고 싶지 않은 예외인 경우 무시할 수 있지만 개발자의 실수로 예외 처리를 누락할 수 있다는 단점이 있습니다.
</details>

---

<details>
  <summary>4. 컬렉션에는 어떤 것들이 있나요?</summary>
  
중복을 허용하며 순서가 있는 요소의 집합인 `List`, 중복을 허용하지 않으며 순서가 없는 요소의 집합인 `Set`, 키-값 쌍의 데이터를 저장하며 키의 중복을 허용하지 않고 값의 중복을 허용하는 `Map`이 있습니다.
</details>
<details>
  <summary>4-1. Map과 Set은 어떻게 중복을 판단하나요?</summary>

HashMap은 `hashCode()` 메서드를 통해 객체의 해시값을 비교하고 동일한 경우 `equals()` 메서드로 동일한 객체인지 비교합니다. HashSet은 내부적으로 HashMap을 사용하고 있기 때문에 역시 `hashCode()`와 `equals()`를 이용하여 동일한 키인지 판단합니다.

</details>
<details>
  <summary>4-2. HashMap은 어떻게 해시 충돌을 해결하나요?</summary>

Java의 HashMap은 Separate Chaining 방식을 이용하여 충돌을 해결합니다. Java 8이전까지는 링크드 리스트만 사용하였으나 8이후부터는 데이터의 개수가 많아지는 경우 링크드 리스트 대신 트리를 사용하여 성능이 개선되었습니다.

</details>
<details>
  <summary>4-3. HashTable과 ConcurrentHashMap의 차이는 무엇인가요?</summary>

HashTable은 메서드 전체에 synchronized 키워드를 이용하여 동기화를 수행합니다. 이 때문에 쓰레드 안전하긴 하지만 성능이 떨어진다는 단점이 있습니다.

ConcurrentHashMapd은 HashTabler과 달리 synchronized 키워드가 메서드 전체에 붙어 있지 않고 `put()` 메서드 안에 synchronized 블럭이 존재합니다. 읽기 작업에서는 여러 쓰레드가 동시에 읽을 수 있지만 쓰기 작업시에는 특정 버킷에 대한 Lock을 사용합니다. 때문에 같은 버킷이 아니라면 Lock을 기다릴 필요가 없다는 특징이 있습니다. 
</details>

---

<details>
  <summary>5. 불변 객체란 무엇인가요?</summary>
  
객체 생성 이후 내부 데이터가 변하지 않는 객체를 불변 객체라고 합니다. Java의 대표적인 불변 객체로는 String이 있습니다.
</details>
<details>
  <summary>5-1. 불변 객체의 장점은 무엇인가요?</summary>

**Tread-Safe하여 병렬 프로그래밍에 유용하며 동기화를 고려하지 않아도 됩니다.**
멀티 쓰레드 환경에서 불변인 공유 자원은 항상 동일한 값을 반환합니다. 이는 안정성을 보장하고 동기화를 하지 않음으로써 성능상의 이점을 가집니다.

**실패 원자적인 메서드를 만들 수 있습니다.**
객체를 가지고 작업하는 도중 예외가 발생하더라도 불변 객체는 메서드 호출 전의 상태를 유지합니다. 

**사이드 이펙트를 최소화 할 수 있습니다.**
여러 곳에서 객체의 값을 변경한다면 객체의 상태를 예측하기 어려워집니다. 불변 객체는 값의 수정이 불가하기 때문에 안전하게 객체를 사용할 수 있습니다.
</details>

---

<details>
  <summary>1. JDK, JRE, JVM의 차이가 무엇인가요?</summary>
  
jdk는 자바 개발 시 필요한 라이브러리들과 개발 도구들이 포함되어 있는 개발 키트입니다. 자바 프로그램의 실행을 위해 jre를 포함합니다.
jre는 jvm과 자바 프로그램을 실행시킬 때 필요한 라이브러리 api를 함께 묶어서 배포하는 패키지입니다.
jvm은 컴퓨터 상에서 Java 바이트코드로 컴파일 된 프로그램을 실행할 수 있도록 해주는 가상 머신입니다.
</details>
<details>
  <summary>1-1. JVM의 구성요소는 어떻게 되나요?</summary>
  
jvm은 클래스 로더, 런타임 데이터 영역, 실행 엔진으로 구성되어 있습니다.

#### 클래스 로더
클래스 로더는 런타임 중에 클래스를 JVM에 동적으로 로드하는 역할을 담당합니다. 런타임에 클래스가 필요할 때 JRE가 클래스 로더를 호출하고 클래스 로더가 JVM에 메모리를 로드합니다.

#### 실행 엔진
실행 엔지는 클래스 파일을 실행하는 역할을 담당합니다. 인터프리터, 짓 컴파일러, 가비지 컬렉터로 구성되어 있습니다.

#### 런타임 데이터 영역
런타임 데이터 영역은 PC 레지스터, 스택 영역, 힙 영역, 메서드 영역, 네이티브 메서드 스택으로 구성되어 있습니다.

##### PC 레지스터
jvm에서 실행되는 각각의 스레드는 자체 PC 레지스터를 가지며 현재 실행중인 명령어 주소를 저장합니다.

##### 스택 영역
각각의 스레드는 생명주기를 함께하는 JVM 스택을 가집니다. JVM 스택은 메서드가 호출될 때마다 새롭게 생성되는 프레임을 가지고 있습니다. 프레임에는 지역 변수, 중간 연산 결과, 메서드 호출 및 반환 정보 등이 포함되어 있습니다.

##### 힙 영역
힙 영역은 모든 jvm 스레드가 공유하는 영역으로 객체 및 배열의 메모리가 할당되는 영역입니다. 힙은 jvm의 생명주기와 함께하며 힙에 생성된 객체는 가비티 컬렉터라고 불리는 저장소 관리 시스템에 의해 회수됩니다.

##### 메서드 영역
메서드 영역은 JVM 스레드가 공유하는 영역으로 프로그램을 실행하는데 필요한 공통 데이터를 관리합니다. 포함되는 데이터로는
**클래스 정보**
- 클래스의 바이트 코드, 필드, 메서드와 생성자 등 모든 실행 코드가 존재합니다.

**static 영역**
- static 변수들을 보관합니다.

**런타임 상수 풀**
- 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관합니다.

##### 네이티브 메서드 스택
자바가 아닌 다른 언어로 작성된 메서드를 사용하기 위해 C스택이라고 하는 기존 스택을 사용할 수 있습니다.
</details>
<details>
  <summary>1-2. 가비지 컬렉터의 작동 방식에 대해 설명해주세요.</summary>
  
가비지 컬렉터는 힙 영역에 할당했던 메모리 중 더 이상 참조되지 않는 객체를 모아 주기적으로 제거합니다.
GC는 힙의 young 영역에서 일어나는 minor GC와 old 영역에서 일어나는 메이저 GC로 나뉩니다.

##### Minor GC

모든 객체는 처음에 young 영역의 eden 영역에 위치합니다. eden 영역이 가득 차면 minor GC가 실행됩니다. Mark and Sweep이라는 과정을 거쳐 참조되지 않는 객체의 메모리는 해제되고서 살아남은 객체는 survivor 영역으로 이동합니다. 다시 eden 영역이 가득차면 앞선 과정이 반복되며 살아남은 객체는 비어있는 survivor 영역으로 번갈아나가면서 이동하게 됩니다.

##### Major GC

young 영역에서 충분히 오래 살아남은 객체는 old 영역으로 이동하게 되고 old 영역이 가득차면 Major GC가 실행됩니다. old 영역은 young 영역에 비해 큰 메모리 공간을 가지고 있기 때문에 minor GC에 비해 긴 시간이 소요됩니다.
</details>
<details>
  <summary>1-3. G1 GC에 대해 설명해주세요.</summary>
  
G1 GC는 힙 영역을 region이라는 단위로 나누어 관리합니다. 각 region은 메모리 회수와 할당을 단위가 되며 기존 gc와 동일하게 young, old 영역으로 구분됩니다. 이 때, 여러 region이 필요한 사이즈가 큰 객체(humongous object)는 곧바로 old 영역에 할당됩니다.

(추가 작성 필요)
</details>

---

<details>
  <summary>2. 객체 지향이란 무엇인가요?</summary>

객체 지향이란 상태와 행위를 가진 객체들의 상호 협력을 통해 하나의 프로그램을 구성하는 프로그래밍 패러다임입니다.

##### 객체 지향의 장점
변경에 유연하게 대응할 수 있습니다.
클래스 단위로 모듈화시켜서 개발 하기 때문에 대규모 소프트웨어 개발에 적합합니다.
클래스 단위로 수정이 가능하기 때문에 유지 보수가 편리합니다.

##### 객체 지향의 단점
설계시 많은 노력이 필요합니다.
절차 지향에 비해 상대적으로 처리 속도가 느립니다.
</details>
<details>
  <summary>2-1. 객체 지향의 특성에 관해 설명해주세요.</summary>
  
객체 지향의 특성은 캡슐화, 추상화, 다형성, 상속이 있습니다.

##### 캡슐화

캡슐화는 객체의 로직을 내부로 숨겨서 클라이언트가 알지 못하도록 하여 외부에 영향을 받지 않고 변경할 수 있는 것입니다.

##### 추상화

추상화는 클라이언트에게 객체의 세부적인 처리 내용을 알리지 않고 객체가 어떤 역할을 하는지 공통적이고 추상적인 내용만 알리는 것을 말합니다.

##### 다형성

다형성은 동일한 메시지를 이해할 수 있으며 저마다의 방식대로 작동하는 다양한 객체들과 협력할 수 있는 것을 말합니다.

##### 상속

상속은 부모 클래스의 속성과 기능을 자식 클래스에 물려주면서 동일한 메시지를 이해할 수 있는 계층 관계를 형성하는 것입니다.

이러한 객체 지향의 4대 특성을 통해 객체의 응집도는 높이고 외부와의 결합도는 낮추며 각각의 객체의 로직은 자유롭게 발전해나가며 변경에 유연하게 대응할 수 있습니다.
</details>
<details>
  <summary>2-2. 객체 지향의 설계 원칙에 대해 설명해주세요.</summary>
  
SOLID 원칙은 소프트웨어 구조를 변경에 유연하고, 이해하기 쉽고, 많은 소프트웨어 시스템에 사용도리 수 있는 컴포넌트의 기반을 만드는데 목적이 있습니다.

##### 단일 책임 원칙

어떠한 모듈이 변경된다면 그 이유는 오직 하나뿐이어야 한다는 것입니다.

##### 개방-폐쇄 원칙

소프트웨어 개체는 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 합니다.

##### 리스코프 치환 원칙

상위 타입의 객체가 할 수 있는 일은 어떤 하위 타입의 객체가 와도 할 수 있어야 합니다.

##### 인터페이스 분리 원칙

모든 일을 처리하는 하나의 슈퍼 클래스보다 여러 개의 분리된 인터페이스를 의존해야 합니다.

##### 의존성 역전 원칙

변동성이 큰 구현체가 아닌 안정된 추상 인터페이스를 의존해야 합니다.
</details>
<details>
  <summary>2-3. 왜 단일 책임 원칙을 지켜야 하나요?</summary>

단일 책임을 어긴 경우 우발적 중복이 발생할 수 있습니다. 서로 다른 목적으로 묘듈을 사용하는 액터가 둘 이상 있을 때, 하나의 액터에 의해 발생한 변경으로 인해 다른 액터의 로직에 영향을 줄 수 있습니다. 예를 들어 코드 중복을 제거하기 위해 추출한 메서드가 어디서 사용되고 있는지 제대로 파악하지 변경이 이루어지는 경우 이러한 상황이 발생할 수 있습니다.

변경이 발생한 클래스는 재컴파일이 필요합니다. 책임에 따라 적절하게 클래스를 분리하면 서로 다른 클라이언트의 변경으로 인해 재컴파일하는 상황을 피할 수 있습니다.
</details>

---

<details>
  <summary>3. 자바 예외의 계층 구조에 대해 설명해주세요.</summary>
  
자바의 다른 모든 객체처럼 예외 역시 최상위에 Object를 두고 있으며 그 하위에 최상위 예외인 Throwable이 있습니다. Throwable의 하위에는 Exception과 Error가 있습니다. Error는 메모리 부족과 같은 애플리케이션에서 복구 불가능한 시스템 오류가 속하며 이외에 개발자의 실수록 발생하며 애플리케이션에서 처리할 수 있는 오류인 Exception이 있습니다.
</details>
<details>
  <summary>3-1. 체크 예외와 언체크 예외의 차이가 무엇인가요?</summary>

##### 체크 예외

체크 예외는 컴파일러가 체크하는 예외입니다. 이는 개발자가 잡아서 처리하거나 명시적으로 메서드를 호출한 곳으로 던지게 됩니다. 만일 어떠한 곳에서도 예외를 잡아서 처리하지 않고 `main()`까지 가면 예외 로그를 출력하면서 시스템이 종료됩니다. 

##### 언체크 예외

언체크 예외는 컴파일러가 체크하지 않는 에외입니다. 개발자가 잡아서 처리할 수도 있지만 처리하지 않는 경우 별도로 `throws`를 선언하지 않고 생략할 수 있습니다.
</details>
<details>
  <summary>3-2. 체크 예외와 언체크 예외의 장단점에 대해 설명해주세요.</summary>

##### 체크 예외 장단점

체크 예외는 컴파일러가 체크하기 때문에 개발자가 실수로 예외를 누락하지 않도록 도와줍니다. 반면 개발자가 크게 신경쓰고 싶지 않은 예외까지 모두 챙겨야 하며 명시적으로 던지는 과정에서 예외 발생 지점부터 해당 예외를 잡아서 처리하는 부분까지 해당 예외에 대한 의존관계가 발생합니다. 해당 예외를 발생시키는 기술이 변경된다면 모든 게층에 걸쳐 예외의 파급 효과가 발생할 수 있습니다.

##### 언체크 예외 장단점

언체크 예외는 컴파일러가 체크하지 않기 때문에 크게 신경쓰고 싶지 않은 예외인 경우 무시할 수 있지만 개발자의 실수로 예외 처리를 누락할 수 있다는 단점이 있습니다.
</details>

---

<details>
  <summary>4. 컬렉션에는 어떤 것들이 있나요?</summary>
  
중복을 허용하며 순서가 있는 요소의 집합인 `List`, 중복을 허용하지 않으며 순서가 없는 요소의 집합인 `Set`, 키-값 쌍의 데이터를 저장하며 키의 중복을 허용하지 않고 값의 중복을 허용하는 `Map`이 있습니다.
</details>
<details>
  <summary>4-1. Map과 Set은 어떻게 중복을 판단하나요?</summary>

HashMap은 `hashCode()` 메서드를 통해 객체의 해시값을 비교하고 동일한 경우 `equals()` 메서드로 동일한 객체인지 비교합니다. HashSet은 내부적으로 HashMap을 사용하고 있기 때문에 역시 `hashCode()`와 `equals()`를 이용하여 동일한 키인지 판단합니다.

</details>
<details>
  <summary>4-2. HashMap은 어떻게 해시 충돌을 해결하나요?</summary>

Java의 HashMap은 Separate Chaining 방식을 이용하여 충돌을 해결합니다. Java 8이전까지는 링크드 리스트만 사용하였으나 8이후부터는 데이터의 개수가 많아지는 경우 링크드 리스트 대신 트리를 사용하여 성능이 개선되었습니다.

</details>
<details>
  <summary>4-3. HashTable과 ConcurrentHashMap의 차이는 무엇인가요?</summary>

HashTable은 메서드 전체에 synchronized 키워드를 이용하여 동기화를 수행합니다. 이 때문에 쓰레드 안전하긴 하지만 성능이 떨어진다는 단점이 있습니다.

ConcurrentHashMap은 HashTable과 달리 synchronized 키워드가 메서드 전체에 붙어 있지 않고 `put()` 메서드 안에 synchronized 블럭이 존재합니다. 읽기 작업에서는 여러 쓰레드가 동시에 읽을 수 있지만 쓰기 작업시에는 특정 버킷에 대한 Lock을 사용합니다. 때문에 같은 버킷이 아니라면 Lock을 기다릴 필요가 없다는 특징이 있습니다. 
</details>

---

<details>
  <summary>5. 불변 객체란 무엇인가요?</summary>
  
객체 생성 이후 내부 데이터가 변하지 않는 객체를 불변 객체라고 합니다. Java의 대표적인 불변 객체로는 String이 있습니다.
</details>
<details>
  <summary>5-1. 불변 객체의 장점은 무엇인가요?</summary>

**Tread-Safe하여 병렬 프로그래밍에 유용하며 동기화를 고려하지 않아도 됩니다.**
멀티 쓰레드 환경에서 불변인 공유 자원은 항상 동일한 값을 반환합니다. 이는 안정성을 보장하고 동기화를 하지 않음으로써 성능상의 이점을 가집니다.

**실패 원자적인 메서드를 만들 수 있습니다.**
객체를 가지고 작업하는 도중 예외가 발생하더라도 불변 객체는 메서드 호출 전의 상태를 유지합니다. 

**사이드 이펙트를 최소화 할 수 있습니다.**
여러 곳에서 객체의 값을 변경한다면 객체의 상태를 예측하기 어려워집니다. 불변 객체는 값의 수정이 불가하기 때문에 안전하게 객체를 사용할 수 있습니다.
</details>

---

<details>
  <summary>6. 자바에서 임계 영역을 보호하기 위한 방법에는 어떤 것이 있나요?</summary>
  
synchronized와 volatile을 이용한 atomic 변수들을 사용할 수 있습니다.

#### synchronized
synchronized 키워드는 동기화가 필요한 메서드 혹은 코드블럭에 사용할 수 있습니다. synchronized로 지정된 임계영역에 접근한 스레드는 lock을 얻고 다른 스레드는 접근할 수 없습니다. 스레드가 작업을 종료하고 lock을 반환하면 다른 스레드가 임계영역에 접근할 수 있습니다.

#### volatile
volatile 키워드를 사용한 자원은 read나 write 작업이 CPU 캐시 메모리가 아니라 항상 메인 메모리를 통해서 이루어지도록 하는 것입니다. 이를 통해 가시성 문제를 해결할 수 있습니다. 그러나 가시성 문제와 별개로 여러 스레드에서 공유 자원에 동시에 접근하는 경우 발생하는 동시성 문제는 해결할 수 없습니다. 동시성 문제의 해결을 위해서는 CAS 알고리즘을 이용해서 해결할 수 있으며 이러한 방식으로 구현된 AtomicInteger, AtomicLong과 같은 변수들이 있습니다. 
</details>
<details>
  <summary>6-1. 가시성 문제는 어째서 발생하나요?</summary>

멀티 스레드에서 스레드는 성능 향상을 위해 메인 메모리에서 읽은 변수 값을 CPU 캐시 메모리에 저장해서 이용합니다. 이로 인해 다른 스레드에서 변경한 값을 알지 못하여 의도하지 않은 결과가 발생합니다.
</details>
<details>
  <summary>6-2. CAS 알고리즘의 작동 방식에 대해서 설명해주실 수 있나요?</summary>

CAS 알고리즘은 기대값과 변경값을 이용합니다. volatile 키워드를 이용하여 메인 메모리의 변수에 접근하여 기대값과 메모리의 변수가 가지고 있는 값이 같다면 새로운 값을 반영합니다. 이를 통해 원자적인 연산이 이루어질 수 있습니다. 
</details>

---

<details>
  <summary>7. 자바의 stream(not stream api)에 대해 설명해주세요.</summary>
  
자바에서 모든 데이터 입출력은 스트림을 통해 이루어집니다. 스트림(stream)은 단방향으로 데이터가 흐르며 프로그램을 기준으로 데이터가 들어오는 것을 입력 스트림(InputStream), 나가는 것을 출력 스트림(stream)이라 합니다. 
</details>

---

<details>
  <summary>8. final 키워드에 대해 설명해주세요.</summary>
  
final은 변수, 메서드, 객체에 붙일 수 있는 키워드입니다. final 변수는 값은 재할당이 불가능합니다. final 메서드는 자식 클래스에서 오버라이드 할 수 없습니다. final 객체는 상속할 수 없습니다.
</details>
<details>
  <summary>8-1. static 키워드에 대해 설명해주세요.</summary>

static은 변수, 메서드, 객체에 붙일 수 있는 키워드입니다. static 변수는 클래스가 메모리에 올라올 때 메서드 영역에 생성되며 클래스.변수 이름으로 접근 가능합니다. static 메서드는 정적 메서드라 하여 인스턴스를 생성하지 않고 클래스.메서드 이름으로 접근 가능합니다. 인스턴스가 만들어지지 않았기 때문에 다른 필드, 메서드에 접근하지 못합니다. static 클래스는 중첩 클래스를 만드는데 사용하며 static이 붙지 않은 내부 클래스와는 달리 내부 클래스 인스턴스 참조를 가지지 않습니다.
</details>

---

<details>
  <summary>1. 프로세스와 쓰레드의 차이에 대해 설명해주세요.</summary>
  프로세스는 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않습니다. 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있습니다.<br>
쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, 그 이외의 메모리 영역(Code, Data, Heap)영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있습니다. 쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행됩니다.
</details>
<details>
  <summary>1-1. 멀티 프로세스와 멀티 쓰레드의 특징에 대해 설명해주세요.</summary>
  멀티 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행된다는 장점이 있지만 멀티 쓰레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있습니다.

멀티 쓰레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만 하나의 쓰레드에 문제가 생기면 전체 쓰레드가 영향을 받으며 동기화 문제도 있다는 단점이 있습니다.
</details>
<details>
  <summary>1-2. 멀티 쓰레드의 동시성과 병렬성을 설명해주세요.</summary>
  동시성은 멀티 작업을 위해 싱글 코어에서 여러 개의 쓰레드가 번갈아 실행하는 것을 말합니다.
(동시에 실행하는 것처럼 보이지만 사실은 번갈아가며 실행하고 있는 것임)

병렬성은 멀티 작업을 위해 멀티 코어에서 한 개 이상의 쓰레드를 포함하는 각 코어들을 동시에 실행하는 것을 말합니다.
</details>
<details>
  <summary>1-3. 멀티 쓰레드 환경에서의 주의사항을 설명해주세요.</summary>
  멀티 쓰레드 프로그램을 개발한다면, 다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호 배제를 제거해 교착 상태를 예방하고 동기화 기법을 통해 동시성 문제가 발생하지 않도록 발생하지 않도록 주의해야 합니다.
</details>

---

<details>
  <summary>2. 데드락에 대해 설명해주세요</summary>
  둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황을 말합니다.

예를 들어, 자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면 두 프로세스는 서로 자원을 얻기 위해 무한정 기다리게 됩니다.
</details>
<details>
  <summary>2-1. 데드락의 조건에 대해 설명해주세요</summary>
  <li>비선점 (Nonpreemptive) : 다른 프로세스의 자원을 뺏을 수 없음.</li>
<li>순환 대기 (Circular wait) : 두 개 이상의 프로세스가 자원 접근을 기다릴 때, 관계가 순환적 구조.</li>
<li>점유 대기 (Hold & Wait) : 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구.</li>
<li>상호 배제(Mutual Exclusion) : 한 번에 한 프로세스만 공유 자원에 접근 가능하며, 접근 권한이 제한적일 경우.</li>
</details>

---

<details>
  <summary>3. Critical Section(임계영역)에 대해 설명해주세요.</summary>
  임계 영역이란 프로세스간에 공유 자원을 접근하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 이용하게끔 보장해줘야 하는 영역을 말합니다.

임계 영역 문제를 해결하기 위해서는 아래의 3가지 조건을 충족해야 합니다.

1. 상호 배제: 한 프로세스가 임계구역에 들어가면 다른 프로세스는 들어갈 수 없음
2. 한정 대기: 어떤 프로세스도 무한 대기를 하면 안됨
3. 진행의 융통성: 한 프로세스가 다른 프로세스의 진행을 방해해서는 안됨
</details>
<details>
  <summary>3-1. 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이에 대해 설명해주세요.</summary>
  뮤텍스는 Lock을 사용해 하나의 프로세스나 쓰레드를 단독으로 실행하게 합니다.

반면에 세마포어는 공유자원에 세마포어 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있습니다.

(세마포어의 변수 → 공유자원의 개수를 나타내는 변수)
</details>

---

<details>
  <summary>4. 컨텍스트 스위칭(Context Switching)이 무엇인지 설명해주세요.</summary>
  멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)을 교체하는 작업을 말합니다.
</details>
<details>
  <summary>4-1. 선점형 스케줄링과 비선점형 스케줄링의 차이를 설명해주세요</summary>
  선점형은 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음을 말하고,

비선점형은 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음을 말합니다.
</details>
<details>
  <summary>4-2. 선점형 스케줄링 알고리즘 중 1개, 비선점형 스케줄링 알고리즘 중 1개를 각각 설명해주세요</summary>
  비선점형 중에는 실행시간이 가장 짧은 프로세스를 선택하는 SJF(Shortest Job First) 알고리즘이 있습니다. 일반적으로 좋은 평균 처리 시간을 제공하지만, 긴 시간을 필요로 하는 프로세스가 우선순위가 계속 밀려 실행되지 못하고 무기한으로 대기하게 되는 기아 현상이 일어날 수 있습니다.

선점형 중에는 각 프로세스 실행에 고정된 시간 조각을 할당하는 Round Robin 알고리즘 있습니다. 모든 프로세스가 CPU를 균등하게 공유할 수 있다는 장점이 있지만, 잦은 컨텍스트 전환으로 오버헤드가 발생하기 때문에 시간 할당량의 길이를 적절하게 선택해야 합니다.
</details>
<details>
  <summary>4-3. 콘보이 현상(convoy effect)이란 무엇이고, 콘보이 현상이 발생될 수 있는 CPU 스케줄러 알고리즘은 무엇인지 설명해주세요.</summary>
  콘보이 현상이란 작업 시간이 긴 프로세스가 먼저 큐에 도착해서 다른 프로세스의 실행 시간이 전부 늦춰져 효율성을 떨어뜨리는 현상을 말합니다.

FCFS(First-Come First Served) 스케줄링은 비선점형으로, 순차적으로 먼저 큐에 들어온 작업부터 실행하므로 콘보이 현상이 발생할 수 있습니다.
</details>

---

<details>
  <summary>5. 가상 메모리란 무엇이며, 왜 사용할까요?</summary>
  가상메모리는 RAM의 부족한 용량을 보완하기 위해, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식입니다. 프로세스를 실행할 때 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 두며 필요할 때마다 교체하면서 사용하게 됩니다.

1. 가상 메모리는 물리적 메모리보다 큰 프로그램을 실행할 수 있게 해줍니다. 예를 들어 게임 프로그램의 크기가 50GB인데 메모리 16GB로 게임을 돌릴 수 있게 됩니다.
2. 또한 개발자는 메모리 관리의 복잡성을 신경 쓸 필요 없이, 충분한 메모리를 가지고 있는 것 처럼 개발 할 수 있습니다.
3. 여러 프로그램이 동시에 실행되는 환경에서 메모리 사용을 최적화하고 프로세스 간의 메모리 충돌을 방지합니다.
4. 각 프로세스는 독립적인 주소 공간을 가지므로, 프로세스간의 무단 접근을 방지합니다.
</details>
<details>
  <summary>5-1. 페이지 폴트란?</summary>
  가상 메모리를 사용함으로 인해, 실제 메모리에 원하는 페이지가 없는 상황이 발생할 수 있습니다. 가상 메모리에는 존재하지만 실제 메모리에는 없는 데이터나 코드에 접근할 경우 발생하는 에러가 페이지 폴트입니다. 가상메모리는 하드디스크에 저장되어 있기 때문에 디스크로부터 읽어와야 하는데, 디스크 I/O에 의한 속도의 저하가 발생하는 문제가 있습니다.
</details>
<details>
  <summary>5-2. 페이지 교체 알고리즘이란?</summary>
  실제 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 가상 메모리에 저장하게 됩니다. 이러한 대상 페이지를 선정하는 것을 페이지 교체 알고리즘이라 하며, 이를 통해 페이지 폴트를 줄이고 시스템의 성능을 향상시킬 수 있습니다.
</details>
<details>
  <summary>5-3. 페이지 교체 알고리즘 중 LRU에 대해 설명해주세요.</summary>
  가장 오래 전에 사용된 페이지를 교체하는 방식으로 각 페이지가 마지막으로 접근된 시간을 기록해 관리합니다.
</details>

---

<details>
  <summary>6. 컨텍스트 스위칭이란?</summary>
  CPU가 현재 작업 중인 프로세스(쓰레드)에서 다른 프로세스(쓰레드)로 넘어갈 때 지금까지의 프로세스(쓰레드) 상태를 저장하고, 새 프로세스(쓰레드)의 저장된 상태를 다시 적재하는 작업
</details>
<details>
  <summary>6-1. 컨텍스트 스위칭이 자주 발생하면 어떤 문제가 발생하나요?</summary>
  <li> 여러 오버헤드가 발생한다.<ul>
    <li> 컨텍스트 스위칭은 커널 모드에서 실행된다. → 커널 모드로 전환되는 데 시간 소요</li>
    <li> CPU의 레지스터 상태를 교체한다. → 교체하는 데 시간 소요</li>
    <li> 멀티 프로레스에서 스위칭은, 메모리 주소 체계가 다르기 때문에 이 때는 메모리 주소 관련된 처리를 추가로 수행해야 한다.</li></ul></li>
<li> 캐시 오염 문제<ul>
    <li> 컨텍스트 스위칭이 일어나면, 또 사용할 것이라고 예상을 하고 캐시에 데이터나 값을 저장한 캐시가 의미가 없는 데이터가 되어버린다. 컨텍스트 스위칭이 일어난 직후에 캐시에 가봤자, 이전에 프로세스에서 실행되었던 정보들을 저장해놓고 있을 가능성이 매우 높기 때문에, 내가 필요한 정보는 없을 가능성이 매우 높아진다.</li></ul></li>
</details>
<details>
  <summary>6-2. 컨텍스트 스위칭을 최소화하기 위한 방법</summary>
  <li> 멀티 프로세스에서 멀티 스레드로 변환 (But, 상황을 잘 고려해야 함.)</li>
<li> 싱글톤 패턴: 하나의 인스턴스를 모든 쓰레드에서 공유하고 있기 때문에, 메모리 작업 관련 오버헤드 발생 X</li>
</details>

---

<details>
  <summary>7. 동기, 비동기에 대해 설명해주세요</summary>
  관점: 호출되는 함수의 작업 완료 여부를 신경 쓰냐 안 쓰냐

<li> 동기: 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것</li>
<li> 비동기: 함수 A가 함수 B를 호출할 때 콜백 함수를 함께 전달해서, 함수 B의 작업이 완료되면 함께 보낸 콜백 함수를 실행한다. 이때 함수 A는 함수 B를 호출한 후로 함수 B의 작업 완료 여부에는 신경쓰지 않는다.</li>
</details>
<details>
  <summary>7-1. 블로킹, 논블로킹에 대해 설명해주세요</summary>
  관점: 다른 주체가 작업할 때 자신의 제어권이 없는지 있는지
<li> 블로킹: 제어권을 넘기고 제어권을 다시 돌려받을 때까지 기다렸다가 돌려받고 동작을 시작</li>
<li> 논블로킹: 제어권을 넘기지 않고 자기 코드 계속 실행</li>
</details>

---

<details>
  <summary>8. 메모리의 힙 영역을 너무 크게 잡으면 어떻게 될까요?</summary>
  GC 수행 시간이 길어집니다.<br>
힙 영역은 스택 영역과 다르게 직접 생성된 변수를 제거를 하면서 메모리를 관리해야 합니다.<br>
만약 메모리의 힙 영역이 너무 크다면, 넓은 힙 영역에 존재하는 동적 변수에 대해 참조 여부를 확인해야 하기 때문에 Garbage Collect의 수행시간이 너무 길어지게 됩니다.
</details>

---

<details>
  <summary>9. 크롬 브라우저에서 한 탭에 오류가 생기더라도, 다른 탭에 영향을 끼치지 않습니다. 그렇다면 각각의 크롬 탭은 프로세스일까요? 쓰레드일까요?</summary>
  크롬 탭이 쓰레드라면, 한 크롬 탭에서 오류가 생기면 다른 크롬 탭에도 영향이 갈 수 있습니다. 따라서 한 탭에 오류가 생기더라도 다른 탭에 영향을 끼치지 않는다는 특성에 의해, 크롬 탭은 별개의 프로세스인 것을 알 수 있습니다.
</details>
<details>
  <summary>9-1. 쓰레드마다 독립적으로 할당하는 2가지에 대해 말해주세요</summary>
  쓰레드는, 독립적으로 스택 영역과 PC Register를 갖고 있습니다. 
</details>
<details>
  <summary>9-2. 이유는?</summary>
  그 이유는 쓰레드의 정의와 컨텍스트 스위칭에 있습니다.

1. 독립적으로 스택 영역을 갖는 이유 :

스택 영역은 함수의 실행과 관련이 있습니다. 독립적으로 스택을 갖는다는 것은 곧 독립적으로 함수 호출이 가능하다는 것을 의미합니다. 즉, 프로세스 내의 독립적인 실행 흐름을 만들기 위해 쓰레드마다 스택 영역을 갖습니다.

2. 독립적으로 PC Register를 갖는 이유 :

PC Register 값은, 쓰레드가 명령어를 어디까지 수행했는 지를 나타냅니다. 쓰레드는 CPU를 할당받았다가, 스케줄러에 의해서 선점당해 컨텍스트 스위칭이 일어납니다. 따라서 다시 해당 쓰레드가 실행될 때 어디까지 실행이 되었는지 알아야 하므로 독립적으로 PC Register 값을 갖게 됩니다.
</details>

---

<details>
  <summary>10. 프로세스 간의 통신은 어떻게 진행되나요?</summary>
  커널 영역에서 IPC를 사용하여 프로세스들 간에 통신을 제공한다.

- **Pipe** : 2개의 프로세스를 연결하고 하나의 프로세스는 데이터를 쓰기만 하고 다른 프로세스는 데이터를 읽기만 한다.
- **Message Queue** : FIFO 자료구조를 가지는 통신 설비로 커널에서 관리한다. 장점은 비동기 방식이기에 방대한 처리량이 있다면 큐에 넣은 후 나중에 처리할 수 있다. 단점은 데이터가 많이 쌓일수록 추가적인 메모리 자원이 필요하다
- **Shared memory** : 프로세스가 공유 메모리 할당을 커널에 요청하면 해당 프로세스에 메모리 공간을 할당해주고 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다. 장점은 중개자 없이 곧바로 메모리에 적용할 수 있기 때문에 모든 IPC 중 가장 빠르다. 단점은 메시지 전달 방식이 아니기 때문에 데이터를 읽어야 하는 시점을 알 수 없습니다.
</details>
<details>
  <summary>10-1. CPU의 메모리 I/O 도중 생기는 병목 현상 해결 방법</summary>
  메모리를 계층화하여 병목현상을 해결하고 있습니다. 자주 접근하는 데이터의 경우에는 캐시에 저장하여 접근 속도를 향상 시킴으로써 부하를 줄이고 있습니다.
</details>

---
<details>
  <summary>1. 프로세스와 쓰레드의 차이에 대해 설명해주세요.</summary>
  프로세스는 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않습니다. 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있습니다.<br>
쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, 그 이외의 메모리 영역(Code, Data, Heap)영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있습니다. 쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행됩니다.
</details>
<details>
  <summary>1-1. 멀티 프로세스와 멀티 쓰레드의 특징에 대해 설명해주세요.</summary>
  멀티 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행된다는 장점이 있지만 멀티 쓰레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있습니다.

멀티 쓰레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만 하나의 쓰레드에 문제가 생기면 전체 쓰레드가 영향을 받으며 동기화 문제도 있다는 단점이 있습니다.
</details>
<details>
  <summary>1-2. 멀티 쓰레드의 동시성과 병렬성을 설명해주세요.</summary>
  동시성은 멀티 작업을 위해 싱글 코어에서 여러 개의 쓰레드가 번갈아 실행하는 것을 말합니다.
(동시에 실행하는 것처럼 보이지만 사실은 번갈아가며 실행하고 있는 것임)

병렬성은 멀티 작업을 위해 멀티 코어에서 한 개 이상의 쓰레드를 포함하는 각 코어들을 동시에 실행하는 것을 말합니다.
</details>
<details>
  <summary>1-3. 멀티 쓰레드 환경에서의 주의사항을 설명해주세요.</summary>
  멀티 쓰레드 프로그램을 개발한다면, 다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호 배제를 제거해 교착 상태를 예방하고 동기화 기법을 통해 동시성 문제가 발생하지 않도록 발생하지 않도록 주의해야 합니다.
</details>

---

<details>
  <summary>2. 데드락에 대해 설명해주세요</summary>
  둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황을 말합니다.

예를 들어, 자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면 두 프로세스는 서로 자원을 얻기 위해 무한정 기다리게 됩니다.
</details>
<details>
  <summary>2-1. 데드락의 조건에 대해 설명해주세요</summary>
  <li>비선점 (Nonpreemptive) : 다른 프로세스의 자원을 뺏을 수 없음.</li>
<li>순환 대기 (Circular wait) : 두 개 이상의 프로세스가 자원 접근을 기다릴 때, 관계가 순환적 구조.</li>
<li>점유 대기 (Hold & Wait) : 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구.</li>
<li>상호 배제(Mutual Exclusion) : 한 번에 한 프로세스만 공유 자원에 접근 가능하며, 접근 권한이 제한적일 경우.</li>
</details>

---

<details>
  <summary>3. Critical Section(임계영역)에 대해 설명해주세요.</summary>
  임계 영역이란 프로세스간에 공유 자원을 접근하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 이용하게끔 보장해줘야 하는 영역을 말합니다.

임계 영역 문제를 해결하기 위해서는 아래의 3가지 조건을 충족해야 합니다.

1. 상호 배제: 한 프로세스가 임계구역에 들어가면 다른 프로세스는 들어갈 수 없음
2. 한정 대기: 어떤 프로세스도 무한 대기를 하면 안됨
3. 진행의 융통성: 한 프로세스가 다른 프로세스의 진행을 방해해서는 안됨
</details>
<details>
  <summary>3-1. 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이에 대해 설명해주세요.</summary>
  뮤텍스는 Lock을 사용해 하나의 프로세스나 쓰레드를 단독으로 실행하게 합니다.

반면에 세마포어는 공유자원에 세마포어 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있습니다.

(세마포어의 변수 → 공유자원의 개수를 나타내는 변수)
</details>

---

<details>
  <summary>4. 컨텍스트 스위칭(Context Switching)이 무엇인지 설명해주세요.</summary>
  멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)을 교체하는 작업을 말합니다.
</details>
<details>
  <summary>4-1. 선점형 스케줄링과 비선점형 스케줄링의 차이를 설명해주세요</summary>
  선점형은 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음을 말하고,

비선점형은 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음을 말합니다.
</details>
<details>
  <summary>4-2. 선점형 스케줄링 알고리즘 중 1개, 비선점형 스케줄링 알고리즘 중 1개를 각각 설명해주세요</summary>
  비선점형 중에는 실행시간이 가장 짧은 프로세스를 선택하는 SJF(Shortest Job First) 알고리즘이 있습니다. 일반적으로 좋은 평균 처리 시간을 제공하지만, 긴 시간을 필요로 하는 프로세스가 우선순위가 계속 밀려 실행되지 못하고 무기한으로 대기하게 되는 기아 현상이 일어날 수 있습니다.

선점형 중에는 각 프로세스 실행에 고정된 시간 조각을 할당하는 Round Robin 알고리즘 있습니다. 모든 프로세스가 CPU를 균등하게 공유할 수 있다는 장점이 있지만, 잦은 컨텍스트 전환으로 오버헤드가 발생하기 때문에 시간 할당량의 길이를 적절하게 선택해야 합니다.
</details>
<details>
  <summary>4-3. 콘보이 현상(convoy effect)이란 무엇이고, 콘보이 현상이 발생될 수 있는 CPU 스케줄러 알고리즘은 무엇인지 설명해주세요.</summary>
  콘보이 현상이란 작업 시간이 긴 프로세스가 먼저 큐에 도착해서 다른 프로세스의 실행 시간이 전부 늦춰져 효율성을 떨어뜨리는 현상을 말합니다.

FCFS(First-Come First Served) 스케줄링은 비선점형으로, 순차적으로 먼저 큐에 들어온 작업부터 실행하므로 콘보이 현상이 발생할 수 있습니다.
</details>

---

<details>
  <summary>5. 가상 메모리란 무엇이며, 왜 사용할까요?</summary>
  가상메모리는 RAM의 부족한 용량을 보완하기 위해, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식입니다. 프로세스를 실행할 때 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 두며 필요할 때마다 교체하면서 사용하게 됩니다.

1. 가상 메모리는 물리적 메모리보다 큰 프로그램을 실행할 수 있게 해줍니다. 예를 들어 게임 프로그램의 크기가 50GB인데 메모리 16GB로 게임을 돌릴 수 있게 됩니다.
2. 또한 개발자는 메모리 관리의 복잡성을 신경 쓸 필요 없이, 충분한 메모리를 가지고 있는 것 처럼 개발 할 수 있습니다.
3. 여러 프로그램이 동시에 실행되는 환경에서 메모리 사용을 최적화하고 프로세스 간의 메모리 충돌을 방지합니다.
4. 각 프로세스는 독립적인 주소 공간을 가지므로, 프로세스간의 무단 접근을 방지합니다.
</details>
<details>
  <summary>5-1. 페이지 폴트란?</summary>
  가상 메모리를 사용함으로 인해, 실제 메모리에 원하는 페이지가 없는 상황이 발생할 수 있습니다. 가상 메모리에는 존재하지만 실제 메모리에는 없는 데이터나 코드에 접근할 경우 발생하는 에러가 페이지 폴트입니다. 가상메모리는 하드디스크에 저장되어 있기 때문에 디스크로부터 읽어와야 하는데, 디스크 I/O에 의한 속도의 저하가 발생하는 문제가 있습니다.
</details>
<details>
  <summary>5-2. 페이지 교체 알고리즘이란?</summary>
  실제 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 가상 메모리에 저장하게 됩니다. 이러한 대상 페이지를 선정하는 것을 페이지 교체 알고리즘이라 하며, 이를 통해 페이지 폴트를 줄이고 시스템의 성능을 향상시킬 수 있습니다.
</details>
<details>
  <summary>5-3. 페이지 교체 알고리즘 중 LRU에 대해 설명해주세요.</summary>
  가장 오래 전에 사용된 페이지를 교체하는 방식으로 각 페이지가 마지막으로 접근된 시간을 기록해 관리합니다.
</details>

---

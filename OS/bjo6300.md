<details>
  <summary>1. 운영체제가 무엇인가요?</summary>

  운영체제는 하드웨어 자원을 관리하고, 응용 프로그램와 하드웨어 사이를 중재하는 인터페이스를 의미한다.
</details>
<details>
  <summary>1-1. 커널은 무엇인가요?</summary>

`메모리에 상주하는 운영체제의 핵심부분`이다. 

프로그램이 실행되기 위해서는 메인 메모리에 적재된 상태여야 한다. 운영체제 역시 프로그램이기 때문에 메인 메모리에 적재 되어야 하나, 운영체제의 크기가 너무 커서 비효율적이다.
</details>
<details>
  <summary>1-2. 커널에서 제공하는 기능을 사용하려면 어떻게 해야할까요?</summary>
  
`System Call`을 이용한다. System Call은 사용자나 응용프로그램이 커널에서 제공하는 기능을 사용하기 위한 `인터페이스`이다.

운영체제는 커널이 제공하는 서비스를 '시스템 콜'을 사용해야만 이용할 수 있도록 제한함으로써 `컴퓨터 자원을 보호`하면서 사용자나 응용프로그램에게 서비스를 제공할 수 있다.
</details>

---

<details>
  <summary>2. 메모리의 구조를 영역에 따라 설명해주세요.</summary>

1. 코드 영역(텍스트 영역) :

실행할 프로그램의 코드가 저장되는 영역으로, '텍스트' 영역이라고도 부릅니다. CPU는 해당 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.

2. 데이터 영역(static 영역) :

전역 변수와 정적 변수가 저장되는 영역으로, 프로그램이 시작하는 동시에 할당되며, 프로그램이 종료되면 소멸합니다.

3. 힙 영역 (Heap) :

사용자가 직접 관리하는 영역이며 메모리 공간이 동적으로 할당 및 헤제됩니다. 동적으로 할당되므로 new로 생성한 object가 많아질 수록 힙 영역의 크기가 늘어나게 됩니다.

4. 스택 영역 (Stack) :

함수의 호출에 따른 지역변수와 매개변수가 저장되는 영역으로, 컴파일 시 크기가 결정됩니다. 함수의 호출과 함께 할당되고, 함수의 호출이 종료되면 소멸합니다.
</details>
<details>
  <summary>2-1. stack overflow와 out of memory의 차이는 무엇인가요?</summary>
  
stack overflow

- 프로그램이 가능한 `stack 영역`보다 많이 사용할 때 발생
- 예시) 재귀 구현 시 종료 조건을 설정하지 않은 경우

 out of memory

- `heap 영역`을 더 이상 사용할 수 없을 때 발생
- 예시) 메모리를 할당만하고 해제하지 않는 경우
</details>

---

<details>
  <summary>3. 프로세스와 쓰레드에 대해 설명해주세요.</summary>

**1) 프로세스**

- 메인 메모리(주기억장치)에 적재되어 실행되는 프로그램을 의미합니다.
- PCB, code, data, heap, stack 영역을 갖습니다.
- 프로세스별 각각의 영역을 갖기 때문에 별다른 동기화 작업이 필요하지 않습니다.
- 프로세스별 각각의 영역을 갖기 때문에 context switching 비용이 큽니다.
- 프로세스 쓰레드보다 무겁기 때문에 생성 시간이 더 깁니다.
- 한 프로세스에서 오류가 생기더라도 다른 프로세스에 영향을 주지 않습니다.

**2) 쓰레드**

- 한 프로세스 내의 실행 단위, 실행의 흐름을 의미합니다.
- stack 영역만 별도로 갖고, 나머지 영역(code, data, heap)에 대해서는 해당 쓰레드를 포함한 프로세스의 자원을 공유합니다.
- stack 영역 외부의 공유 자원에 대해 접근 시 동기화 작업이 필요합니다.
- stack 영역 외부를 공유하므로 컨텍스트 스위칭 비용이 적습니다.
- 쓰레드는 프로세스보다 가볍기 때문에 생성 시간이 더 짧습니다.
- 한 쓰레드에서 오류가 생기면, 나머지 프로세스 내의 쓰레드에 영향을 줄 수 있습니다.

</details>
<details>
  <summary>3-1. 쓰레드마다 독립적으로 할당하는 2가지에 대해 설명해주세요.</summary>

스택 영역, PC Register를 독립적으로 할당합니다.

스택 영역 : 독립적으로 스택을 갖는다는 것은 곧 독립적으로 함수 호출이 가능하다는 것을 의미합니다. 즉, 프로세스 내의 독립적인 실행 흐름을 만들기 위해 쓰레드마다 스택 영역을 갖습니다.

PC Register : PC Register 값은 쓰레드가 명령어를 어디까지 수행했는 지를 나타냅니다. 쓰레드는 CPU를 할당받았다가, 스케줄러에 의해서 선점당해 컨텍스트 스위칭이 일어납니다. 따라서 다시 해당 쓰레드가 실행될 때 어디까지 실행이 되었는지 알아야 하므로 독립적으로 PC Register 값을 갖게 됩니다.
</details>
<details>
  <summary>3-2. 멀티 프로세스와 멀티 쓰레드의 차이에 대해 설명해주세요.</summary>

- 멀티 프로세스는 하나의 프로세스가 망가지더라도 다른 곳에 영향을 미치지 않지만 멀티 스레드는 스레드에 문제가 생기면 전체가 망가질 수 있다.
- 멀티 프로세스는 컨텍스트 스위칭시 메모리 영역 모두를 교체해야하지만 멀티 스레드는 스택과 레지스터 일부만 변경하면 되서 `컨텍스트 스위칭 비용`이 적다.
</details>

---

<details>
  <summary>4. 컨텍스트 스위칭이란 무엇인가요?</summary>

CPU/코어에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것
</details>
<details>
  <summary>4-1. 프로세스A, 프로세스B가 있을 때 컨텍스트 스위칭 과정에 대해 설명해주세요.</summary>

A라는 프로세스가 running 상태이고 B라는 프로세스가 ready 상태라고 할 때,

1. 스케줄러가 A 프로세스의 실행을 중단하고 B 프로세스를 실행할 것을 요청함
2. A프로세스에서 Stack의 데이터 위치를 가리키고 있는 `SP(Stack pointer)`의 값과 다음 실행해야하는 코드의 주소값을 가지고 있는 `PC(Program Counter)`의 값을 PCB에 저장함 (운영체제에서 관리)SP와 PC는 모두 중앙처리장치 안의 레지스터이다.
3. A프로세스는 ready 또는 block 상태로 바뀌고, CPU에서 B 프로세스를 실행함. 이 과정을 통해 B 프로세스의 상태가 ready에서 running으로 바뀌는데, 이 작업을 디스패치(dispatch)라고 한다.
4. 반대로 다시 B프로세스에서 A프로세스로 컨텍스트 스위칭을 할 경우, B프로세스의 SP값과 PC값을 PCB에 저장하고(이 때 PCB는 A프로세스의 위치값을 저장하는 PCB와는 별도로 생성되는 메모리 공간임) A프로세스의 PCB에서 SP값과 CP값을 찾아 SP와 PC에 덮어씌움.
</details>
<details>
  <summary>4-2. 컨텍스트 스위칭이 발생하는 예시를 설명해주세요.</summary>

I/O 작업은 오랜 시간이 걸리기 때문에 그동안 CPU는 대기 상태에 들어갑니다. 

컨텍스트 스위칭을 통해 다른 프로세스나 쓰레드의 작업으로 전환한다면, CPU의 사용률을 높일 수 있습니다.

컨텍스트 스위칭을 진행하는 동안 다른 작업을 할 수 없는데(오버헤드), 보통 이 시간보다 I/O 작업이 더 오래 걸리기 때문에 컨텍스트 스위칭을 하는 것이 효율적입니다. 또한 컨텍스트 스위칭이 있기 때문에 여러 프로세스를 처리할 수 있습니다.
</details>

---

<details>
  <summary>5. Blocking과 Non-Blocking에 대해 설명해주세요.</summary>

Blocking : 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날때까지 **기다렸다가** 자신의 작업을 시작하는 것

Non-Blocking : 다른 주체의 작업에 **관련없이** 자신의 작업을 하는 것
</details>
<details>
  <summary>5-1. 동기와 비동기의 차이에 대해 설명해주세요.</summary>

Synchronous (동기) : 작업을 동시에 수행하거나, 동시에 끝나거나, **끝나는 동시에 시작함을 의미**

Asynchronous (비동기) : 시작, 종료가 일치하지 않으며, **끝나는 동시에 시작을 하지 않음**을 의미 (일을 바로 처리하지 않아도 괜찮다.)

<예시>

Blocking & Sync

- 결과를 기다리다가(Blocking) 반환하면 해당 업무를 바로 처리(Sync) → 자바의 scanner

Non-Blocking & Sync

- 결과는 기다리지 않지만(Non-Blocking) 결과 여부를 자주 요청 후 해당 업무 바로 처리(Sync) → 게임에서 맵을 넘어갈 때 (해당 데이터를 가져올 때 로딩창의 비율)

Blocking & Async

- 결과를 기다리다가(Blocking) 반환해도 할 일이 있으면 끝내고(Async) 반환된 일을 처리 → 굳이 안쓴다. (개발자가 실수할 때)

Non-Blocking & Async

- 결과를 기다리지 않고(Non-Blocking) 결과를 받으면 할 일을 먼저 끝내고(Async) 반환된 일을 처리 → 자바스크립트에서 API 요청을 하고 다른 작업을 하다가 콜백을 통해서 추가적인 작업을 할 때
</details>
<details>
  <summary>5-2. 동시성과 병렬성이 어떻게 다른지 설명해주세요.</summary>
  
동시성은 멀티 프로그래밍 (Multi-Programming)에서 나온 개념으로, 주기억장치에 여러 프로세스를 적재해서 Context Switching을 통해 동시에 실행되는 것 처럼 보이게 하는 것을 의미합니다. 실제로는 동시에 실행되는 것이 아니라, 번갈아 실행하는 것입니다. 싱글 코어에서 멀티스레드를 동작시키기 위한 방식입니다.

병렬성은 멀티 프로세싱 (Multi-Processing)에서 나온 개념으로, 실제로 동시에 여러 프로세스를 병렬적으로 실행하는 방식입니다. 병렬적으로 실행하기 위해서는 CPU가 멀티코어여야 합니다.

</details>

---

<details>
  <summary>6. thread-safe란 무엇인가요?</summary>

멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없는 것을 말한다.
</details>
<details>
  <summary>6-1. Race Condition과 Critical Section이 무엇이고, 경쟁상태를 막기 위해 어떤 방법을 사용하는지 설명해주세요.</summary>

두 개 이상의 쓰레드가 공유자원에 대해 접근하려고 서로 경쟁하는 것을 'Race Condition(경쟁상태)'라고 합니다.

이 공유자원이 존재하는 구간으로 Race Condition이 일어날 수 있는 영역을 'Critical Section(임계영역)'이라고 합니다.

이러한 임계영역에 대한 경쟁상태를 제거하기 위해서 한 공유자원에 대해서 한 쓰레드에만 접근을 허락하도록 하는 '상호배제(Mutual Exclusion)'를 사용합니다.
</details>

<details>
  <summary>6-2. DeadLock의 정의와 발생 조건에 대해 설명하고 해결 방법에 대해 설명해주세요.</summary>

DeadLock(교착상태)는, 두 개 이상의 프로세스나 쓰레드가 서로 자원을 기다리면서 무한히 대기하는 상태를 의미합니다.

DeadLock이 발생하기 위한 조건은 4가지가 있습니다.

- 상호 배제 (Mutual Exclusion)
    - 한 자원에 여러 프로세스가 동시에 접근할 수 없다.
- 점유 대기 (Hold and Wait)
    - 하나의 자원을 소유한 상태에서 다른 자원을 기다린다.
- 비선점 (Non-preemption)
    - 프로세스가 어떤 자원의 사용을 끝낼 때까지 프로세스의 자원을 뺏을 수 없다.
- 순환 대기 (Circular Wait)
    - 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다.

<해결 방법>

- 예방(Prevention)
    - 교착 상태 조건 중 **하나를 제거함**으로 데드락이 발생하지 않도록 예방하는 방식
    - 자원 낭비가 심하다.
- 회피(Avoidance)
    - **데드락 발생 가능성을 인정하면서도 적절하게 회피하는 방식**
    - 은행원 알고리즘
        - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하는 알고리즘
        - 발생하지 않으면 자원을 할당하고, 발생하면 다른 프로세스가 자원을 해제할 때까지 대기한다.
        - 안전상태: 시스템이 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태
        - 항상 안전 상태를 유지할 수 있다는 장점이 있으나 최대 자원 요구량을 미리 알아야 하고 항상 불안전 상태를 방지해야 하므로 자원 이용도가 낮다.
- 회복(Recovery)
    - 은행원 알고리즘과 유사하게 시스템의 자원 할당 상태를 갖고 데드락이 발생했는지 여부를 탐색한다.
    - 탐지했다면 데드락을 회복한다.
        - 데드락 상태의 프로세스 모두 중단시키기
        - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키기
        - 자원 섬점을 통해 해결하기(교착 상태에 있는 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에 할당)
</details>

<details>
  <summary>6-3. 식사하는 철학자 문제에서 데드락이 언제 발생하는지 설명하고, 해결 방법을 제시해주세요.</summary>

"식사하는 철학자 문제"

다섯 명의 철학자가 원탁에 앉아 있고, 각자의 앞에는 스파게티가 있고 양옆에 포크가 하나씩 있다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없다. 이때 철학자가 스파게티를 먹기 위해서는 양 옆의 포크를 동시에 들어야 한다.

모든 철학자가 방에 입장한 후, 각자의 왼쪽포크를 5명이 모두 드는 경우에 DeadLock이 발생합니다.

1. 5명 모두 자신의 왼쪽 포크를 들고 있으므로 '점유대기'
2. 남이 포크를 뺏어주지 않음 '비선점'
3. 서로 오른쪽 포크를 놓기만을 기다림 '환형대기'
4. 각 포크에 대해 한 사람만 들 수 있음 '상호배제'

이 문제를 해결하기 위해서, 카운팅 세마포어를 사용합니다.

방에 대한 입장 정원을 카운팅 세마포어로 설계해, 최대 4명만 들어온다면 방 안의 모든 사람들이 왼쪽 포크를 든다 하더라도 DeadLock이 일어나지 않습니다.
</details>

<details>
  <summary>6-4. 뮤텍스와 세마포어에 대해 설명해주세요.</summary>

- 뮤텍스
    - **오직 1개만의 스레드(또는 프로세스)만 접근** 할 수 있다.
    - 1개만 접근 가능하므로 반드시 락을 획득한 프로세스가 락을 해제해야 한다.
- 세마포어
    - **세마포어 변수만큼의 스레드(또는 프로세스)가 접근** 할 수 있다.
    - 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있다.
</details>


<details>
  <summary>0. 운영체제의 역할은 무엇인가요?</summary>

운영체제는 응용 프로그램과 사용자로부터 모든 컴퓨터 자원을 보호하고 효율적으로 관리하는 소프트웨어입니다. 하드웨어 인터페이스를 통해 다양한 하드웨어의 호환성을 제공하고 사용자 인터페이스를 통해 사용자에게 편의성을 제공합니다.
</details>
<details>
  <summary>0-1. 커널이란 무엇인가요?</summary>

커널은 프로세스, 메모리 관리와 같은 운영체제의 핵심 기능을 구현한 프로그램입니다. 컴퓨터 실행 시 가장 먼저 실행되며 커널이 모든 컴퓨터 자원을 관리하기 때문에 사용자나 응용 프로그램은 커널을 통해서만 컴퓨터 자원에 접근할 수 있습니다.
</details>
<details>
  <summary>0-2. 시스템 호출에 대해서 설명해주세요.</summary>

시스템 호출은 커널이 자신을 보호하기 위해 만든 인터페이스입니다. 응용 프로그램과 사용자로부터 컴퓨터 자원을 보호하고 오직 시스템 호출을 통해서 컴퓨터 자원을 사용하기 위한 요청을 할 수 있습니다.
</details>
<details>
  <summary>0-3. 시분할 시스템에 대해 설명해주세요.</summary>

시분할 시스템은 CPU 사용 시간을 잘게 쪼개어 여러 작업에 나누어줌으로써 동시에 실행되는 것처럼 보이게 합니다. 오늘날 대부분의 컴퓨터에서는 시분할 시스템이 사용됩니다. 
</details>

---

<details>
  <summary>1. 멀티 프로세스와 멀티 스레드에 대해 설명해주세요.</summary>

멀티 스레드란 하나의 프로세스가 동시에 여러 개의 일을 수행하는 것입니다. 한 프로세스 내의 여러개의 스레드가 각각의 스택과 레지스터를 가지고 프로세스의 나머지 메모리 영역을 공유하게 됩니다.
멀티 프로세스는 여러 개의 프로세스가 시분할 시스템에서 동시에 처리되는 것을 말합니다. 각각의 프로세스는 독립된 메모리 공간을 차지합니다.
</details>
<details>
  <summary>1-1. 둘 사이의 차이점은 어떤 것이 있나요?</summary>

멀티 스레드는 스택을 제외한 프로세스의 메모리 공간을 공유합니다. 때문에 하나의 스레드가 뻗으면 다른 스레드까지 함께 뻗으면서 전체 작업이 중지될 수 있습니다.
멀티 프로세스는 각각의 독립된 메모리 공간을 가지기 때문에 하나의 프로세스가 뻗어도 다른 프로세스는 지속적으로 작업을 수행할 수 있습니다.
</details>
<details>
  <summary>1-2. 고아 프로세스와 좀비 프로세스가 무엇인지 설명해주세요.</summary>

고아 프로세스는 자식 프로세스가 종료되기 전에 부모 프로세스가 먼저 종료되어 남은 자식 프로세스를 말합니다. 좀비 프로세스는 자식 프로세스가 종료되었는데도 부모 프로세스가 자원을 회수하지 않은 자식 프로세스를 말합니다.

고아 프로세스와 자식 프로세스가 많아지면 자원이 낭비되기 때문에 운영체제는 주기적으로 반환되지 못한 자원을 회수해야 합니다.
</details>

---

<details>
  <summary>2. 프로세스는 무엇인가요?</summary>

프로세스는 프로그램이 메모리에 올라와서 CPU를 할당받아 실행되는 것을 프로세스라 합니다. 

#### 프로그램이 메모리에 올라올 때 어떤 일이 벌어지나요?
프로세스가 메모리에 올라오면 프로세스를 처리하기 위한 다양한 정보가 들어있는 PCB가 만들어집니다. PCB는 OS가 해당 프로세스를 실행하기 위해 관리하는 데이터 구조이므로 운영체제 영역에 만들어지게 됩니다. 프로세스가 종료되면 PCB 역시 폐기됩니다.

PCB에 포함되어 있는 정보는 다음과 같은 것들이 있습니다.

- 프로세스 구분자(PID): 메모리에 있는 여러 개의 프로세스를 구분합니다.
- 메모리 관련 정보: 메모리 위치 정보, 메모리 보호를 위한 경계 레지스터, 한계 레지스터
- 각종 중간값: 다음에 실행할 명령어 주소를 저장하는 프로그램 카운터, 각종 중간값을 보관중인 레지스터들
</details>
<details>
  <summary>2-1. 프로세스의 상태는 어떻게 관리되나요?</summary>

CPU 스케줄러는 프로세스가 생성된후 종료될 때까지의 모든 상태 변화를 조정합니다. 스케줄링은 규모에 따라 고수준, 중간 수준, 저수준 스케줄링으로 구분됩니다.

##### 고수준 스케줄링(장기 스케줄링, 작업 스케줄링)
고수준 스케줄링은 시스템 내의 전체 작업 수를 조절합니다. 작업 요청이 오면 시스템 자원을 고려하여 작업 승인 여부를 결정하며 이에 따라 시스템 내에서 실행 가능한 프로세스의 총 개수가 결정됩니다. 이를 멀티 프로그래밍 정도(degree of multiprogramming)이라고 합니다.

##### 저수준 스케줄링(단기 스케줄링)
저수준 스케줄링은 어떤 프로세스에 CPU를 할당할지 결정하고, 대기 상태로 보낼지 결정합니다.

##### 중간 수준 스케줄링
중간 수준 스케줄링은 시스템의 부하를 조절합니다. 일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스가 원만하게 작동하도록 지원합니다.
</details>
<details>
  <summary>2-2. 프로세스 간에 데이터를 주고 받기 위한 방법은 무엇인가요?</summary>

운영체제는 프로세스 간에 쉽게 데이터를 주고 받을 수 있는 통신 방법을 제공하며 이를 IPC라고 합니다. 주요 방법으로는 공유 메모리, 파이프, 소켓이 있습니다.
</details>
<details>
  <summary>2-3. 파이프와 소켓에 대해 자세히 설명해주세요.</summary>

파이프는 IPC를 위하여 OS가 제공하는 통신 기법입니다. 통신을 위해 단방향 파이프 2개가 필요하며 쓰기 연산을 하면 데이터가 전송되고 읽기 연산을 하면 데이터를 받습니다. 데이터를 쓰는 순간 자동으로 다른 프로세스의 대기 상태가 종료되어 데이터 동기화가 이루어집니다.

소켓은 네트워크로 연결된 컴퓨터에서 데이터를 주고받기 위한 통신입니다. 소켓은 프로세스 동기화를 지원하며 소켓 1개로도 양방향 통신이 가능합니다. 서버 프로세스(데몬)는 소켓을 이용하여 여러 클라이언트에게 서비스를 제공합니다.
</details>

---

<details>
  <summary>3. 가상 메모리에 대해 설명해주세요.</summary>

가상 메모리는 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술입니다. 스왑 영역을 이용하여 물리 메모리가 가득 차면 일부 프로세스를 스왑 영역으로 보내고(스왑아웃) 몇 개의 프로세스가 종료되면 프로세스를 메모리로 가져옵니다(스왑인).

가상 메모리 시스템에서 가상 주소는 물리 메모리나 스왑 영역 중 한 곳에 위치합니다. 메모리 관리자는 가상 주소와 물리 주소를 일대일로 매핑한 테이블로 관리합니다.
</details>
<details>
  <summary>3-1. 가상 메모리의 메모리 할당 기법에는 어떤 것이 있나요?</summary>

고정 분할 방식을 이용하는 페이징 기법과 가변 분할 방식을 이용하는 세그먼테이션 기법이 있습니다.

#### 각 방식에 대해서 설명해주세요.
**페이징 기법**은 고정 분할 방식을 이용한 가상 메모리 관리 기법입니다. 프로세스의 논리 주소 공간을 페이지(page), 물리 메모리 주소 공간을 프레임(frame)이라고 부릅니다. 페이지와 프레임의 크기는 동일하며 가상 주소를 물리 주소로 변환하기 위한 페이지 테이블을 가집니다.

페이지 테이블은 하나의 열로 구성되며 위에서부터 차례로 페이지 0과 연결되는 프레임 번호가 있습니다. 각 프로세스는 운영체제 영역에 존재하는 페이지 테이블에 빠르게 접근하기 위한 페이지 테이블 기준 레지스터(PTBR)을 가집니다.

**세그먼테이션 기법**은 가변 분할 방식을 이용한 가상 메모리 관리 기법으로 물리 메모리를 프로세스 크기에 따라 가변적으로 나누어 사용합니다. 페이징 기법과 마찬가지로 가상 주소를 물리 주소로 변환하는데 세그먼테이션 테이블을 사용합니다.

세그먼테이션 기법의 장점은 프로세스 단위로 메모리를 관리하기 때문에 세그먼테이션 테이블이 작고 단순해진다는 것이지만 물리 메모리의 외부 단편화로 관리가 복잡해집니다.

세그먼테이션 테이블에는 세그먼트의 크기를 나타내는 limit와 물리 메모리의 시작 주소를 나타내는 address가 있습니다. limit는 메모리를 보호하는 역할을 하며 사용자가 크기보다 더 큰 주소에 접근하려고하면 메모리 관리자는 해당 프로세스를 강제 종료합니다.

</details>

<details>
  <summary>3-2. 요구 페이징에 대해 설명해주세요.</summary>

실행에 필요한 페이지만 메모리에 올려놓고 사용자가 요구할 때 해당하는 페이지를 메모리로 가져오는 것을 요구 페이징이라 합니다.

프로세스의 일부만 메모리에 가져오면서 얻을 수 있는 장점은 다음과 같습니다.

- 메모리를 효율적으로 관리할 수 있습니다. 메모리가 꽉 차면 관리하기 어려우므로 가능하면 적은 양의 프로세스만 유지합니다.
- 응답 속도를 향상시킬 수 있습니다. 용량이 큰 프로세스르르 전부 메모리로 가져와 실행하면 응답이 늦어질 수 있으므로 필요한 모듈만 올려 실행합니다.
</details>

<details>
  <summary>3-3. 요구 페이지가 메모리에 없으면 어떤 일이 벌어지나요?</summary>

프로세스가 요청한 페이지가 메모리에 없는 상황을 페이지 부재(page fault)라 합니다. 이 경우 페이지 교체 알고리즘에 따라 대상 페이지를 선정하여 스왑 영역으로 옮깁니다. 이후, 스왑 영역에 있는 요청 페이지를 메모리에 올립니다.
</details>

<details>
  <summary>3-4. 페이지 교체 알고리즘에 대해 알고 있는 것이 있나요?</summary>

FIFO, 최적 알고리즘, 최적 근접 알고리즘인 LRU, LFU, NUR이 있습니다.

#### 최적 근접 알고리즘에 대해서 아는대로 설명해주세요.
LRU(Least Recently Used)는 현재를 기준으로 가장 과거에 사용한 페이지를 스왑 영역으로 보냅니다.
LFU(Least Frequently Used)는 프레임에 있는 페이지마다 사용된 횟수를 세어 가장 적게 사용한 페이지를 스왑 영역으로 보냅니다.
NUR(Not Used Recently)은 참조 비트와 변경 비트를 이용하여 가장 최근에 사용되지 않은 페이지를 스왑 영역으로 보냅니다.
</details>

---

<details>
  <summary>4. 공유 자원과 임계 구역에 대해 설명해주세요.</summary>

공유 자원은 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말합니다. 2개 이상의 프로세스가 공유 자원에 접근하면 경쟁 조건(race condition)이 발생하며 실행 순서에 따라 결과가 변합니다.

공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 임계구역이라 합니다.
</details>
<details>
  <summary>4-1. 임계 구역을 해결하기 위해 필요한 조건에는 어떤 것이 있나요?</summary>

상호 배제(mutual exclusion)

- 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없어야 합니다.

한정 대기(bounded waiting)

- 어떤 프로세스도 임계구역에 진입하지 못하여 무한 대기하지 않아야 합니다.

진행의 융통성(progress flexibility)

- 한 프로세스가 다른 프로세스의 진행을 방해해서는 안됩니다. 프로세스 A의 작업 속도와 관계 없이 공유 자원 공유 자원을 사용하고 있지 않다면 프로세스 B는 접근 가능해야 합니다.
</details>
<details>
  <summary>4-2. 임계 구역을 해결하기 위한 방법에 대해 설명해주세요.</summary>

##### 세마포어(semaphore)
세마포어는 공유 가능한 자원의 수 n을 설정합니다. n이 0보다 크면 임계구역에 진입합니다. n이 0이하이면 큐에 저장되어 있다가 n이 증가하고 동기화 신호를 받으면 임계구역에 진입합니다.

##### 모니터
세마포어는 개발자가 세마포어를 누락하는 경우 임계구역에 곧바로 진입할 수 있는 문제가 있습니다. 이를 방지하기 위해 모든 프로세스가 세마포어를 따르도록 구현한 것이 모니터입니다. 공유 자원을 숨기고 공유 자원에 접근하기 위한 퍼블릭 인터페이스만 제공하여 자원을 보호하고 프로세스 간 동기화할 수 있습니다.

</details>

---

<details>
  <summary>5. 교착 상태에 대해 설명해주세요.</summary>

2개 이상의 작업이 동시에 이루어지는 경우, 다른 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 것을 교착 상태라 합니다.

교착 상태는 다른 프로세스와 공유할 수 없는 자원을 사용하거나 잠금을 사용하는 경우 발생할 수 있습니다.
</details>
<details>
  <summary>5-1. 교착 상태가 발생하는 필요 조건에 대해 설명해주세요.</summary>

상호 배제

- 임계구역으로 보호되는 배타적인 자원은 여러 프로세스가 동시에 사용할 수 없습니다. 배타적인 자원을 사용하면 교착 상태가 발생할 수 있습니다. 

비선점

- 한 프로세스가 사용중인 자원을 다른 프로세스가 빼앗을 수 없다면 교착 상태가 발생할 수 있습니다.

점유와 대기

- 한 프로세스가 다른 프로세스가 필요로 하는 자원을 점유하며 다른 자원을 대기하면 교착 상태가 발생할 수 있습니다.

원형 대기

- 점유와 대기를 하는 프로세스가 원을 이루면 서로 양보하지 않기 때문에 교착 상태가 발생할 수 있습니다.
</details>
<details>
  <summary>5-2. 교착 상태를 해결하기 위한 해결법은 무엇인가요?</summary>

예방

- 교착 상태를 유발하는 네 가지 조건이 발생하지 않도록 무력화합니다. 실효성이 적어 잘 사용되지 않습니다.

회피

- 자원 할당량을 조절하여 교착 상태를 해결합니다. 교착 상태를 발생시키지 않기 위한 자원 할당량을 알 수 없어 사용되지 않습니다.

검출과 회복

- 자원 할당 그래프를 모니터링하면서 교착 상태가 발생하는지 살펴봅니다. 교착 상태가 발생하면 회복 단계가 진행됩니다. 현실적인 방법입니다.
</details>

---

<details>
  <summary>6. 컨텍스트 스위치란?</summary>

문맥 교환은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말합니다. 나가는 PCB에는 지금까지의 작업 내용을 저장하고, 실행 상태로 들어오는 PCB의 내용을 읽어서 상태를 복구하는 작업이 이루어집니다.
</details>
<details>
  <summary>6-1. 타임슬라이스의 크기가 컨텍스트 스위칭에 미치는 영향?</summary>

타임슬라이스가 큰 경우 한 프로세스의 작업이 종료되고 다른 프로세스의 작업이 이루어질 때까지 긴 시간이 걸려 작업이 끊겨 보일 것입니다.

타임슬라이스가 작은 경우 사용자는 프로그램이 동시에 실행되는 것처럼 느끼지만 문맥 교화에 많은 시간이 낭비되어 실제 작업을 처리하는 시간이 줄어들 것입니다.
</details>

---

<details>
  <summary>7. 스레싱이란?</summary>

하드디스크의 입출력이 너무 많아 잦은 페이지 부재로 작업이 멈춘 것 같은 상태를 스레싱이라 합니다.

동시에 실행하는 프로그램의 수를 멀티프로그래밍 정도(degree of multiprogramming)라고 하며 이 정도가 너무 높아지면 스레싱이 발생합니다.

스레싱은 각 프로세스에 프레임을 얼만나 나누어 주는지에도 연관되어 있습니다. 너무 많은 프레임을 할당하여 페이지 부재는 줄었지만 물리 메모리를 낭비하면 전반적인 시스템 성능이 줄어들 수 있습니다. 반대로 너무 적은 프레임을 할당하면 빈번한 페이지 부재가 발생합니다.
</details>
<details>
  <summary>7-1. 프로세스에 프레임을 할당하는 방식에는 어떤 것이 있나요?</summary>

#### 정적 할당
정적 할당 방식은 실행 초기에 프레임을 나누어준 후 크기를 고정하는 방식입니다. 정적 할당 방식은 균등 할당과 비례 할당이 있습니다.

- 균등 할당

  프로세스 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당하는 방식입니다.

- 비례 할당
  
  프로세스의 크기에 비례하여 프레임을 할당하는 방식입니다. 균등 할당보다는 현실적이지만 두 가지 문제가 있습니다.

  - 프로세스가 실행 중에 필요로 하는 프레임을 유동적으로 반영하지 못합니다. 예시로 동영상 플레이어가 있습니다. 동영상 플레이어의 크기는 작지만 재생되는 동영상의 크기 때문에 실행되는 동안 동영상 플레이어보다 큰 메모리를 필요로 합니다.
  - 사용하지 않을 메모리를 처음부터 미리 확보하여 공간을 낭비합니다.

##### 동적 할당
동적 할당은 작업집합 모델과 페이지 부재 빈도를 사용하는 방식이 있습니다.

- 작업집합 모델(working set model)

  지역성 이론을 바탕으로 하며 가장 최근에 접근한 프레임이 이후에도 참조될 가능성이 높다는 가정에서 출발합니다. 최근 일정 시간동안 참조된 페이지들을 집합(working set)으로 만들고 이를 물리 메모리에 유지하여 프로세스 실행을 돕습니다.
  작업 집합 윈도의 크기에 따라 프로세스의 실행 성능이 달라집니다.

- 페이지 부재 빈도(page fault frequency)

  페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산하고 부재 비율의 상한선과 하한선을 설정합니다. 상한선을 초과하면 프레임을 추가로 할당하고 하한선 밑으로 내려가면 할당한 프레임을 회수합니다.

</details>
<details>
  <summary>7-3. 지역성 이론에 대해 설명해주세요.</summary>

지역성은 기억장치에 접근하는 패턴이 메모리 전체 분포되는 것이 아닌 특정 영역에 집중되는 성질을 말합니다.

- 공간의 지역성

  현재 위치에서 가까운 데이터에 접근할 확률이 높음을 의미합니다.
- 시간의 지역성

  현재를 기준으로 가장 가까운 시간에 접근한 데이터가 사용될 확률이 높음을 의미합니다.
- 순차적 지역성

  작업이 순서대로 진행되는 것을 의미합니다.
</details>

---

<details>
<summary>자바의 스레드 모델</summary>
</details>

---
<details>
<summary>동기/비동기, 블로킹/논블로킹에 대해 설명해주세요.</summary>

#### 블로킹
작업이 완료될 때까지 스레드는 차단됩니다.
#### 논블로킹
작업 완료 여부와 관계없이 프로세스가 계속 실행됩니다.
#### 동기
작업을 요청한 후 작업이 완료될 때까지 대기합니다. 작업은 순서대로 실행됩니다.
#### 비동기
작업을 요청한 후 다른 작업을 수행합니다. 콜백과 같은 특정 메커니즘을 이용해 작업 완료 여부를 통지받습니다. 

</details>
<details>
<summary>IO 멀티플렉싱에 대해 설명해주세요.</summary>
IO 멀티플렉싱은 하나의 프로세스로 여러 입출력 작업을 동시에 처리하는 기술입니다. 이를 통해 시스템 자원을 효율적으로 사용하고, 많은 연결을 동시에 관리할 수 있어 서버 프로그래밍에서 주로 활용됩니다.
</details>
<details>
<summary>IO 멀티플렉싱의 원리는 어떻게 되나요?</summary>
IO 멀티플렉싱은 select(), poll(), epoll() 같은 시스템 콜을 사용합니다. 이 함수들은 여러 파일 디스크립터를 모니터링하고, 어떤 디스크립터에 이벤트가 발생했는지 알려줍니다. 프로그램은 이 정보를 바탕으로 준비된 IO 작업만 처리하므로, 블로킹 없이 여러 IO를 효율적으로 관리할 수 있습니다.
</details>
<details>
<summary>파일 디스크립터는 무엇인가요?</summary>
파일 디스크립터는 운영 체제에서 열린 파일이나 I/O 리소스를 식별하는 정수값입니다. 이는 파일, 소켓, 파이프 등 모든 입출력 대상을 추상화하여 일관된 방식으로 접근할 수 있게 해줍니다. 프로그램은 이 번호를 통해 특정 리소스에 대한 읽기, 쓰기 등의 작업을 수행합니다.
</details>
<details>
<summary>IO 멀티플렉싱을 이용하는 예를 설명해주세요.</summary>
레디스는 싱글 스레드 이벤트 루프 모델을 사용하며, IO 멀티플렉싱을 위해 epoll(리눅스) 또는 kqueue(BSD) 같은 고성능 이벤트 통지 인터페이스를 활용합니다. 이를 통해 수많은 클라이언트 연결을 효율적으로 처리합니다. 레디스의 이벤트 루프는 새로운 클라이언트 연결, 클라이언트 요청, 응답 전송 등의 이벤트를 모두 관리하며, 블로킹 없이 빠르게 작업을 전환할 수 있습니다.
</details>

---

<details>
<summary>부동소수점 연산의 문제</summary>
부동소수점이란 실수를 컴퓨터에서 표현하는 방법입니다. 대부분의 프로그래밍 언어는 IEEE 754 표준을 사용해 부동소수점을 표현합니다. 부호(1비트) + 지수부(8비트) + 가수부(23비트)로 구성되어있습니다. 지수부는 음수를 표시하기 위해 `실제 지수 + 바이어스(127)` 값을 지수부 비트값으로 이용합니다.

```
12.375(10) = 1100.011(2) -> 1.100011 * 2^3 -> 0 10000010(3+127) 100011...
-5.25 -> 5.25(10) = 101.01(2) -> 1.0101 * 2^2 -> 1 10000001(2+127) 0101... 
```

컴퓨터는 이진수로 숫자를 표현하는데 십진수의 소수를 이진수로 정확히 표현하지 못하는 문제가 발생합니다. 대부분의 프로그래밍 언어는 IEEE 754 표준을 사용해 부동소수점을 표현합니다. 부호(1비트) + 지수부(8비트) + 가수부(23비트)로 구성되는 제한된 비트로 인해 정밀도에 한계를 가집니다.
</details>

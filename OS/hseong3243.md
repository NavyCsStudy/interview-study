<details>
  <summary>0. 운영체제의 역할은 무엇인가요?</summary>

운영체제는 응용 프로그램과 사용자로부터 모든 컴퓨터 자원을 보호하고 효율적으로 관리하는 소프트웨어입니다. 하드웨어 인터페이스를 통해 다양한 하드웨어의 호환성을 제공하고 사용자 인터페이스를 통해 사용자에게 편의성을 제공합니다.
</details>
<details>
  <summary>0-1. 커널이란 무엇인가요?</summary>

커널은 프로세스, 메모리 관리와 같은 운영체제의 핵심 기능을 구현한 프로그램입니다. 컴퓨터 실행 시 가장 먼저 실행되며 커널이 모든 컴퓨터 자원을 관리하기 때문에 사용자나 응용 프로그램은 커널을 통해서만 컴퓨터 자원에 접근할 수 있습니다.
</details>
<details>
  <summary>0-2. 시스템 호출에 대해서 설명해주세요.</summary>

시스템 호출은 커널이 자신을 보호하기 위해 만든 인터페이스입니다. 응용 프로그램과 사용자로부터 컴퓨터 자원을 보호하고 오직 시스템 호출을 통해서 컴퓨터 자원을 사용하기 위한 요청을 할 수 있습니다.
</details>
<details>
  <summary>0-3. 시분할 시스템에 대해 설명해주세요.</summary>

시분할 시스템은 CPU 사용 시간을 잘게 쪼개어 여러 작업에 나누어줌으로써 동시에 실행되는 것처럼 보이게 합니다. 오늘날 대부분의 컴퓨터에서는 시분할 시스템이 사용됩니다. 
</details>

---

<details>
  <summary>1. 멀티 프로세스와 멀티 스레드에 대해 설명해주세요.</summary>

멀티 스레드란 하나의 프로세스가 동시에 여러 개의 일을 수행하는 것입니다. 한 프로세스 내의 여러개의 스레드가 각각의 스택과 레지스터를 가지고 프로세스의 나머지 메모리 영역을 공유하게 됩니다.
멀티 프로세스는 여러 개의 프로세스가 시분할 시스템에서 동시에 처리되는 것을 말합니다. 각각의 프로세스는 독립된 메모리 공간을 차지합니다.
</details>
<details>
  <summary>1-1. 둘 사이의 차이점은 어떤 것이 있나요?</summary>

멀티 스레드는 스택을 제외한 프로세스의 메모리 공간을 공유합니다. 때문에 하나의 스레드가 뻗으면 다른 스레드까지 함께 뻗으면서 전체 작업이 중지될 수 있습니다.
멀티 프로세스는 각각의 독립된 메모리 공간을 가지기 때문에 하나의 프로세스가 뻗어도 다른 프로세스는 지속적으로 작업을 수행할 수 있습니다.
</details>
<details>
  <summary>1-2. 고아 프로세스와 좀비 프로세스가 무엇인지 설명해주세요.</summary>

고아 프로세스는 자식 프로세스가 종료되기 전에 부모 프로세스가 먼저 종료되어 남은 자식 프로세스를 말합니다. 좀비 프로세스는 자식 프로세스가 종료되었는데도 부모 프로세스가 자원을 회수하지 않은 자식 프로세스를 말합니다.

고아 프로세스와 자식 프로세스가 많아지면 자원이 낭비되기 때문에 운영체제는 주기적으로 반환되지 못한 자원을 회수해야 합니다.
</details>

---

<details>
  <summary>2. 프로세스는 무엇인가요?</summary>

프로세스는 프로그램이 메모리에 올라와서 CPU를 할당받아 실행되는 것을 프로세스라 합니다. 

#### 프로그램이 메모리에 올라올 때 어떤 일이 벌어지나요?
프로세스가 메모리에 올라오면 프로세스를 처리하기 위한 다양한 정보가 들어있는 PCB가 만들어집니다. PCB는 OS가 해당 프로세스를 실행하기 위해 관리하는 데이터 구조이므로 운영체제 영역에 만들어지게 됩니다. 프로세스가 종료되면 PCB 역시 폐기됩니다.

PCB에 포함되어 있는 정보는 다음과 같은 것들이 있습니다.

- 프로세스 구분자(PID): 메모리에 있는 여러 개의 프로세스를 구분합니다.
- 메모리 관련 정보: 메모리 위치 정보, 메모리 보호를 위한 경계 레지스터, 한계 레지스터
- 각종 중간값: 다음에 실행할 명령어 주소를 저장하는 프로그램 카운터, 각종 중간값을 보관중인 레지스터들
</details>
<details>
  <summary>2-1. 프로세스의 상태는 어떻게 관리되나요?</summary>

CPU 스케줄러는 프로세스가 생성된후 종료될 때까지의 모든 상태 변화를 조정합니다. 스케줄링은 규모에 따라 고수준, 중간 수준, 저수준 스케줄링으로 구분됩니다.

##### 고수준 스케줄링(장기 스케줄링, 작업 스케줄링)
고수준 스케줄링은 시스템 내의 전체 작업 수를 조절합니다. 작업 요청이 오면 시스템 자원을 고려하여 작업 승인 여부를 결정하며 이에 따라 시스템 내에서 실행 가능한 프로세스의 총 개수가 결정됩니다. 이를 멀티 프로그래밍 정도(degree of multiprogramming)이라고 합니다.

##### 저수준 스케줄링(단기 스케줄링)
저수준 스케줄링은 어떤 프로세스에 CPU를 할당할지 결정하고, 대기 상태로 보낼지 결정합니다.

##### 중간 수준 스케줄링
중간 수준 스케줄링은 시스템의 부하를 조절합니다. 일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스가 원만하게 작동하도록 지원합니다.
</details>
<details>
  <summary>2-2. 프로세스 간에 데이터를 주고 받기 위한 방법은 무엇인가요?</summary>

운영체제는 프로세스 간에 쉽게 데이터를 주고 받을 수 있는 통신 방법을 제공하며 이를 IPC라고 합니다. 주요 방법으로는 공유 메모리, 파이프, 소켓이 있습니다.
</details>
<details>
  <summary>2-3. 파이프와 소켓에 대해 자세히 설명해주세요.</summary>

파이프는 IPC를 위하여 OS가 제공하는 통신 기법입니다. 통신을 위해 단방향 파이프 2개가 필요하며 쓰기 연산을 하면 데이터가 전송되고 읽기 연산을 하면 데이터를 받습니다. 데이터를 쓰는 순간 자동으로 다른 프로세스의 대기 상태가 종료되어 데이터 동기화가 이루어집니다.

소켓은 네트워크로 연결된 컴퓨터에서 데이터를 주고받기 위한 통신입니다. 소켓은 프로세스 동기화를 지원하며 소켓 1개로도 양방향 통신이 가능합니다. 서버 프로세스(데몬)는 소켓을 이용하여 여러 클라이언트에게 서비스를 제공합니다.
</details>

---

<details>
  <summary>3. 가상 메모리에 대해 설명해주세요.</summary>

가상 메모리는 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술입니다. 스왑 영역을 이용하여 물리 메모리가 가득 차면 일부 프로세스를 스왑 영역으로 보내고(스왑아웃) 몇 개의 프로세스가 종료되면 프로세스를 메모리로 가져옵니다(스왑인).

가상 메모리 시스템에서 가상 주소는 물리 메모리나 스왑 영역 중 한 곳에 위치합니다. 메모리 관리자는 가상 주소와 물리 주소를 일대일로 매핑한 테이블로 관리합니다.
</details>
<details>
  <summary>3-1. 가상 메모리의 메모리 할당 기법에는 어떤 것이 있나요?</summary>

고정 분할 방식을 이용하는 페이징 기법과 가변 분할 방식을 이용하는 세그먼테이션 기법이 있습니다.

#### 각 방식에 대해서 설명해주세요.
페이징 기법은 고정 분할 방식을 이용한 가상 메모리 관리 기법입니다. 가상 주소의 분할된 각 영역을 페이지(page), 물리 메모리의 각 영역은 프레임(frame)이라고 부릅니다. 페이지와 프레임의 크기는 동일하며 가상 주소를 물리 주소로 변환하기 위한 페이지 테이블을 가집니다.

페이지 테이블은 하나의 열로 구성되며 위에서부터 차례로 페이지 0과 연결되는 프레임 번호가 있습니다. 각 프로세스는 운영체제 영역에 존재하는 페이지 테이블에 빠르게 접근하기 위한 페이지 테이블 기준 레지스터(PTBR)을 가집니다.

가변 분할 방식을 이용한 가상 메모리 관리 기법으로 물리 메모리를 프로세스 크기에 따라 가변적으로 나누어 사용합니다. 페이징 기법과 마찬가지로 가상 주소를 물리 주소로 변환하는데 세그먼테이션 테이블을 사용합니다.

세그먼테이션 기법의 장점은 프로세스 단위로 메모리를 관리하기 때문에 세그먼테이션 테이블이 작고 단순해진다는 것이지만 물리 메모리의 외부 단편화로 관리가 복잡해집니다.

세그먼테이션 테이블에는 세그먼트의 크기를 나타내는 limit와 물리 메모리의 시작 주소를 나타내는 address가 있습니다. limit는 메모리를 보호하는 역할을 하며 사용자가 크기보다 더 큰 주소에 접근하려고하면 메모리 관리자는 해당 프로세스를 강제 종료합니다.

</details>
<details>
  <summary>3-2. 페이지 교체 알고리즘에 대해 알고 있는 것이 있나요?</summary>

FIFO, 최적 알고리즘, 최적 근접 알고리즘인 LRU, LFU, NUR이 있습니다.

#### 최적 근접 알고리즘에 대해서 아는대로 설명해주세요.
LRU(Least Recently Used)는 현재를 기준으로 가장 과거에 사용한 페이지를 스왑 영역으로 보냅니다.
LFU(Least Frequently Used)는 프레임에 있는 페이지마다 사용된 횟수를 세어 가장 적게 사용한 페이지를 스왑 영역으로 보냅니다.
NUR(Not Used Recently)은 참조 비트와 변경 비트를 이용하여 가장 최근에 사용되지 않은 페이지를 스왑 영역으로 보냅니다.
</details>

---

<details>
  <summary>4. 공유 자원과 임계 구역에 대해 설명해주세요.</summary>

공유 자원은 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말합니다. 2개 이상의 프로세스가 공유 자원에 접근하면 경쟁 조건(race condition)이 발생하며 실행 순서에 따라 결과가 변합니다.

공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 임계구역이라 합니다.
</details>
<details>
  <summary>4-1. 임계 구역을 해결하기 위해 필요한 조건에는 어떤 것이 있나요?</summary>

상호 배제(mutual exclusion)

- 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없어야 합니다.

한정 대기(bounded waiting)

- 어떤 프로세스도 임계구역에 진입하지 못하여 무한 대기하지 않아야 합니다.

진행의 융통성(progress flexibility)

- 한 프로세스가 다른 프로세스의 진행을 방해해서는 안됩니다. 프로세스 A의 작업 속도와 관계 없이 공유 자원 공유 자원을 사용하고 있지 않다면 프로세스 B는 접근 가능해야 합니다.
</details>
<details>
  <summary>4-2. 임계 구역을 해결하기 위한 방법에 대해 설명해주세요.</summary>

##### 세마포어(semaphore)
세마포어는 공유 가능한 자원의 수 n을 설정합니다. n이 0보다 크면 임계구역에 진입합니다. n이 0이하이면 큐에 저장되어 있다가 n이 증가하고 동기화 신호를 받으면 임계구역에 진입합니다.

##### 모니터
세마포어는 개발자가 세마포어를 누락하는 경우 임계구역에 곧바로 진입할 수 있는 문제가 있습니다. 이를 방지하기 위해 모든 프로세스가 세마포어를 따르도록 구현한 것이 모니터입니다. 공유 자원을 숨기고 공유 자원에 접근하기 위한 퍼블릭 인터페이스만 제공하여 자원을 보호하고 프로세스 간 동기화할 수 있습니다.

</details>

---

<details>
  <summary>5. 교착 상태에 대해 설명해주세요.</summary>

2개 이상의 작업이 동시에 이루어지는 경우, 다른 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 것을 교착 상태라 합니다.

교착 상태는 다른 프로세스와 공유할 수 없는 자원을 사용하거나 잠금을 사용하는 경우 발생할 수 있습니다.
</details>
<details>
  <summary>5-1. 교착 상태가 발생하는 필요 조건에 대해 설명해주세요.</summary>

상호 배제

- 임계구역으로 보호되는 배타적인 자원은 여러 프로세스가 동시에 사용할 수 없습니다. 배타적인 자원을 사용하면 교착 상태가 발생할 수 있습니다. 

비선점

- 한 프로세스가 사용중인 자원을 다른 프로세스가 빼앗을 수 없다면 교착 상태가 발생할 수 있습니다.

점유와 대기

- 한 프로세스가 다른 프로세스가 필요로 하는 자원을 점유하며 다른 자원을 대기하면 교착 상태가 발생할 수 있습니다.

원형 대기

- 점유와 대기를 하는 프로세스가 원을 이루면 서로 양보하지 않기 때문에 교착 상태가 발생할 수 있습니다.
</details>
<details>
  <summary>5-2. 교착 상태를 해결하기 위한 해결법은 무엇인가요?</summary>

예방

- 교착 상태를 유발하는 네 가지 조건이 발생하지 않도록 무력화합니다. 실효성이 적어 잘 사용되지 않습니다.

회피

- 자원 할당량을 조절하여 교착 상태를 해결합니다. 교착 상태를 발생시키지 않기 위한 자원 할당량을 알 수 없어 사용되지 않습니다.

검출과 회복

- 자원 할당 그래프를 모니터링하면서 교착 상태가 발생하는지 살펴봅니다. 교착 상태가 발생하면 회복 단계가 진행됩니다. 현실적인 방법입니다.
</details>

---

<details>
    <summary>1. SELECT 쿼리의 수행 순서를 알려주세요.</summary>
    <ul>
    가장 먼저 FROM절을 통해 조회할 테이블을 지정한다. 이후 JOIN이 있다면 JOIN을 실행하여 하나의 가상 테이블로 결합한다.<br>
    다음으로 WHERE 절을 통해 해당 테이블에서 조건에 맞는 튜플들만 골라낸다.<br> 
    이후 GROUP BY가 있다면 선택한 컬럼을 기준으로 조회한 레코드 목록을 그룹핑한다. HAVING 절은 그룹핑 후에 각 그룹에 사용되는 조건 절로 해당 그룹을 필터링한다.<br>
    다음으로 SELECT절이 수행되어 앞선 처리 후 남은 데이터에서 어떤 열을 출력해줄지 선택한다. 만약 DISTINCT가 있다면 SELECT 이후에 중복 제거를 수행한다.<br>
    이후 ORDER BY를 통해 주어진 조건에 맞게 정렬하고, LIMIT을 통해 결과로 나타난 튜플들 중에서 지정한 갯수만 조회한다.<br>
    추가적으로, Alias(별칭)은 FROM, SELECT, ORDER BY절에서만 사용 가능하다.
    </ul>
</details>
<details>
    <summary>1-a. HAVING과 WHERE의 차이를 설명해주세요.</summary>
    <ul>
    WHERE과 HAVING은 둘 다 조건을 판별한다는 점에서 비슷하지만 WHERE는 GROUP BY 이전에 실행되어, 데이터 전체에 조건을 한다.<br>
    반면 HAVING은 GROUP BY 이후에 실행되어, 그룹 별로 조건을 필터링한다.<br>
    또한 HAVING은 집계 함수와 함께 사용 가능하지만 WHERE는 함께 사용할 수 없다. <br>
    HAVING은 그룹화 또는 집계가 발생한 후 필터링하는 데 사용되고, WHERE는 그룹화 또는 집계가 발생하기 전에 필터링하는데 사용되기 때문이다.
    </ul>
</details>    
<details>
    <summary>1-b. 데이터베이스에서 SELECT 쿼리의 성능을 향상시키는 최적화 기술에 대해 아는대로 말해주세요.</summary>
    <ul>
    <li>인덱스 활용하기
        <ul>
        <li> 인덱스를 사용하면 테이블을 full scan을 하지 않고, 색인화 되어있는 파일을 스캔하여 검색 속도를 향상시킨다.</li>
        <li> 인덱스는 검색 속도를 향상하거나, 조건절에 해당하지 않는 열을 미리 제외하기 위해 많이 사용한다.</li>
        </ul>
    </li>
    <li>SELECT 할 때는 필요한 컬럼만 뽑기
        <ul>
        <li>많은 필드 값을 불러올수록 DB는 더 많은 로드를 부담한다. 컬럼 중에 불필요한 값을 가진 필드가 있다면 과감히 제외하고, 꼭 필요한 열만 불러오는 것이 좋다.</li>
        </ul>
    </li>
    <li>같은 내용의 조건이라면, GROUP BY 연산 시에는 가급적 HAVING보다는 WHERE 절을 사용하기
        <ul>
        <li>쿼리 실행 순서에서, WHERE 절이 HAVING 절보다 먼저 실행된다.
        <li>따라서 WHERE 절로 미리 데이터 크기를 작게 만들면, GROUP BY에서 다뤄야 하는 데이터 크기가 작아지기 때문에 보다 효율적인 연산이 가능하다.</li>
        </ul>
    </li>
    </ul>
</details>

---

<details>
    <summary>2. RDBMS와 NoSQL의 차이에 대해 설명해주세요.</summary>
    <ul>
    <li>
    RDBMS:
        <ul>
        <li>엄격한 스키마, 2차원 테이블 기반의 구조를 갖고 있으며, 관계를 정의하여 데이터의 관계성을 표현한다.</li>
        <li>이러한 관계를 통해 테이블 간의 join이 가능하다.</li>
        <li>장점: 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.</li>
        <li>단점: 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)</li>
        </ul>
    </li>
    <li>
    NoSQL:
        <ul>
        <li>RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리한다.</li>
        <li>장점:
            <ul>
            <li>스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.</li>
            <li>데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만아닌 scale-out 또한 가능하다.</li>
            </ul>
        </li>
        <li>단점: 
            <ul>
            <li>데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.</li>
            <li>스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.</li>
            </ul>
        </li>
        </ul>
    </li>
    </ul>
</details>

<details>
    <summary>2-a. 그렇다면 RDBMS와 NoSQL은 어느 경우에 적합한가요?</summary>
    <ul>
    <li>RDBMS:
        <ul>
        <li>데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우에 사용하는 것이 좋다.</li>
        <li>중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합하다.</li>
        </ul>
    </li>
    <li>NoSQL:
        <ul>
        <li>정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋다. </li>
        <li>NoSQL은 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋다.</li>
        <li>scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB를 Scale-out 해야 되는 시스템에 적합하다.</li>
        </ul>
    </li>
</details>

<details>
    <summary> 2-b. 외래 키의 참조 무결성 제약 조건</summary>
    <ul>
    참조 무결성 제약 조건이란 외래키는 반드시 참조할 수 있는 값 혹은 NULL을 참조해야 한다는 제약 조건이다.<br>
    외래키가 만약 존재하지 않는 값에 대해 참조한다면, 존재하지 않는 값으로는 연관관계를 맺을 수 없으므로 외래키 자체가 의미 없어진다.<br>    
    다만 NULL을 참조하는 것은 가능한데, 이는 존재하지 않는 값을 참조하는게 아니라 아직 참조할 값이 정해지지 않았다는 의미이기 때문이다.    
</details>

---

<details>
    <summary>3. 데이터베이스의 특징은 무엇인가요?</summary>
    <ul>
    <li>실시간 접근성: 사용자의 데이터 요구에 실시간으로 응답</li>
    <li>지속적인 변화: 데이터의 계속적인 삽입, 삭제, 수정을 통해 현재의 정확한 데이터를 유지</li>
    <li>동시 공유: 서로 다른 데이터의 동시 사용뿐만 아니라 같은 데이터의 동시 사용도 지원</li>
    <li>내용 기반 참조: 데이터가 저장된 주소나 위치가 아닌 내용으로 참조
        <ul>
        <li>ex. 재고량이 100개 이상인 제품 이름을 검색하시오</li>
        </ul>
    </li>
    </ul>
</details>    

<details>
    <summary> 2-a. 데이터베이스와 파일시스템의 차이점에 대해 설명해주세요.</summary>
    <ul>
    <li>데이터 조직화
        <ul>
        <li> 데이터베이스 : 테이블, 행, 열 등의 구조를 사용해 데이터를 조직화, 특히 RDB의 경우 테이블간의 관계를 통해 데이터 연결</li>
        <li>파일 시스템 : 파일과 디렉터리(폴더)의 계층적 구조를 사용해 데이터를 조직화</li>
        </ul>
    </li>
    <li>데이터 접근 및 검색
        <ul>
        <li>데이터베이스 : SQL과 같은 쿼리 언어를 사용해 복잡한 검색, 필터링, 정렬 등을 수행</li>
        <li>파일 시스템 : 파일 이름, 경로, 확장자 등을 기반으로 데이터를 검색. (복잡한 쿼리 혹은 연산은 어렵다)</li>
        </ul>
    </li>
    <li>동시성 및 트랜잭션
        <ul>
        <li>데이터베이스 : 여러 사용자가 동시에 데이터에 접근하고 수정할 수 있으며, 트랜잭션 처리를 통해 데이터의 일관성과 무결성 유지</li>
        <li>파일 시스템 : 동시성 관리 기능이 제한적, 트랜잭션 처리를 제공하지 않음</li>
        </ul>
    </li>
    <li>보안 및 무결성
        <ul>
        <li>데이터베이스 : 사용자 권한 관리, 암호화, 데이터 무결성 체크 등의 보안 기능 제공</li>
        <li>파일 시스템 : 기본적인 파일 접근 권한 관리 설정이 가능하나, 고급 보안 기능은 제공하지 않음</li>
        </ul>
    </li>
    <li>백업 및 복구
        <ul>
        <li>데이터베이스 : 정기적인 백업, 로그 기반의 복구, Point-In-Time 복구 등의 기능을 제공</li>
        <li>파일 시스템 : 일반적으로 전체 파일 시스템 혹은 개별 파일의 백업을 수행 (로그 기반의 복구는 제공하지 않음)</li>
        </ul>
    </li>
    <li>용도
        <ul>
        <li>데이터베이스 : 대량의 데이터를 효율적으로 관리하고, 복잡한 쿼리를 수행하기 위해 설계됨</li>
        <li>파일 시스템 : 일반적인 파일 저장 및 관리를 위해 설계됨</li>
        </ul>
    </li>
    </ul>
</details>  

<details>
    <summary>2-b. 데이터 무결성은 무엇이며, 데이터베이스는 어떻게 데이터 무결성을 보장하나요?</summary>
    <ul>
    <li>데이터 무결성은 데이터베이스에 저장된 데이터의 정확성, 일관성, 유효성을 지키는 것이다.</li>
    <li>보통 데이터 무결성은 제약조건으로 데이터베이스 시스템이 강제한다.
        <ul>
        <li>개체 무결성:
            <ul>
            <li>모든 테이블은 기본키를 가져야 하며, 기본키를 구성하는 속성으로 Null과 Unique Key가 있다. 각각 Null값이나 중복된 값을 가질 수 없다는 뜻이다.</li>
            </ul>
        </li>
        <li>참조 무결성:
            <ul>
            <li>참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지되어야 한다. 다시 말해, 외래키 값은 Null이거나 참조하는 테이블으 기본키값과 동일해야 한다.</li>
            </ul>
        </li>
        <li>도메인 무결성:
            <ul>
            <li>테이블에 존재하는 필드의 무결성을을 보장해야 하는 것으로, 데이터의 타입에 맞아야 한다. 예를 들어 '성별'이라는 속성에서 '남', '여'를 제외한 데이터를 제한되어야 한다.</li>
            </ul>
        </li>
        <li>NULL 무결성:
            <ul>
            <li>테이블의 특정 속성 값을 Null이 될 수 없도록 제한했다면 해당 속성에 Null이 있으면 안된다.</li>
            </ul>
        </li>
        <li>고유 무결성:
            <ul>
            <li>테이블의 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 각 레코드가 가지는 값들이 달라야 한다. 예를 들어, '이름, '나이'는 서로 같은 값이 있을 수 있지만, '학번'의 경우, 서로 다른 값을 가져야 한다.</li>
            </ul>
        </li>
        </ul>
    </li>
    <li>데이터 무결성 제약조건 장점:
        <ul>
        <li>스키마를 작성할 떄 무결성 제약조건을 한 번만 명시하면, 데이터베이스가 갱신될 때마다 DBMS가 자동으로 제약조건을 검사하므로 어플리케이션들은 제약조건을 일일이 검사할 필요가 없다.</li>
        <li>제약조건을 사용하면 데이터를 실생활의 의미에 맞게 사용할 수 있다.</li>
        <li>응용 프로그램에서 직접 조건을 유지하는 경우보다 에러가 발생할 가능성이 더 낮다.</li>
        <li>무결성 제약조건 덕분에 데이터에 대한 신뢰도가 올라간다.</li>
        </ul>
    </li>
    </ul>
</details>

---

<details>
    <summary>4. 데이터베이스 언어(DDL, DML, DCL)에 대해 설명해주세요.</summary>
    <ul>
    <li>DDL (정의어 : Data Definition Language): 데이터베이스 구조를 정의, 수정, 삭제하는 언어 ( alter, create, drop )
    </li>
    <li>DML (조작어 : Data Manipulation Language): 데이터베이스내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어 ( select, insert, update, delete )</li>
    <li>DCL (제어어 : Data Control Language): 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어 ( commit, rollback, grant, revoke )</li>
    </ul>
</details>

<details>
    <summary>4-a. DELETE, TRUNCATE, DROP은 어떤 차이가 있나요?</summary>
    <ul>
    세 명령어 모두 삭제하는 명령어라는 공통점이 있다.<br>
    <li>DELETE는 테이블의 데이터를 삭제하는 명령어이고, 조건에 따라 특정한 튜플만 삭제할 수 있고 롤백도 가능하다. 단, 데이터만 지우는 것이지 테이블 용량을 줄이지는 않는다.</li>
    <li>TRUNCATE는 테이블을 생성했을 당시로 데이터를 초기화하는 명령어이다. DELETE FROM table 과 비슷한 기능을 하지만, 테이블의 용량까지 줄인다는 차이가 있다. 또한 롤백도 불가능하다.</li>
    <li>DROP은 데이터가 아니라 테이블 자체를 삭제하는 명령어로 롤백도 불가능하다.</li>
    </ul>
</details>   

<details>
    <summary>4-b. TCL에 대해 설명해주세요</summary>
    <ul>
    DCL에서 트랜잭션을 컨트롤 하는 명령어를 TCL로 분류한다.<br>
    <li>COMMIT: 올바르게 완료한 작업에 대한 데이터를 데이터베이스에 영구적으로 반영</li>
    <li>ROLLBACK: 작업 시작 이전의 상태로 되돌림</li>
    <li>SAVEPOINT: 저장점을 지정, 이후 ROLLBACK과 함께 사용하여 특정 지점까지 ROLLBACK이 가능</li>
    </ul>
</details>

---

<details>
    <summary> 5. 옵티마이저(Optimizer)에 대해 아는대로 말해주세요.</summary>
    <ul>
    옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진이다. <br>
    컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있다. 개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라 옵티마이저라는 곳에서 “이 쿼리문을 어떻게 실행시키겠다!”라는 여러가지 실행 계획을 세우고, 최고의 효율을 갖는 실행계획을 판별한 후 그 실행계획에 따라 쿼리를 수행하게 되는 것이다.
    </ul>
</details>
    

<details>
    <summary>5-a. 옵티마이저의 종류에 대해 말해주세요.</summary>
    <ul>
    <li>비용 기반 최적화(Cost-based Optimizer, CBO):
        <ul>
        <li>현재 대부분의 DBMS가 선택하고 있는 방식이다.</li>
        <li>쿼리를 처리하기 위한 여러 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 실행 계획별 비용을 산출한다.</li>
        <li>산출된 실행 방법 별로 비용이 최소로 소요되는 처리방식을 선택하여 쿼리를 실행한다.</li>
        </ul>
    </li>
    <li>규칙 기반 최적화(Rule-based Optimizer, RBO):
        <ul>
        <li>대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다.</li>
        <li>따라서 항상 같은 쿼리에 대해서는 같은 실행 방법을 만드는데, 데이터의 분포도가 다양하므로 규칙 기반에는 한계점이 존재한다.</li>
        </ul>
    </li>
    </ul>
</details>

<details>
    <summary>5-b. 아키텍처 관점에서, 쿼리 동작 방식</summary>
    <ul>
    <li>쿼리 파서:
        <ul>
        <li>요청으로 들어온 SQL 쿼리를 토큰(MySQL이 인식하는 최소 단위)로 분리해 파서 트리로 만든다.</li>
        <li>기본 SQL 문법과 관련된 오류를 이 과정에서 발견한다.</li>
        </ul>
    </li>
    <li>전처리기:
        <ul>
        <li>파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.</li>
        <li>테이블 이름, 컬럼 이름, 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 접근 권한 확인한다.</li>
        </ul>
    </li>
    <li>옵티마이저:
        <ul>
        <li>사용자의 요청으로 들어온 쿼리를 저렴한 비용으로 빠르게 처리하는 역할을 담당한다</li>
        </ul>
    </li>
    <li>실행엔진:
        <ul>
        <li>옵티마이저와 핸들러 사이에서 역할을 수행하는 것으로, 옵티마이저에 의해 만들어진 실행 계획에 따라 Storage 엔진에게 요청한다.</li>
        <li>또한 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결한다.</li>
        </ul>
    </li>
    <li>스토리지 엔진: </li>
        <ul>
        <li>실행 엔진의 핸들러 API 요청에 따라, 데이터를 디스크로 저장하거나 디스크로부터 읽어오는 작업을 수행한다.</li>
        </ul>
    </li>
    </ul>
</details>
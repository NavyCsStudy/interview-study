<details>
  <summary>1. 트랜잭션이란 무엇인가요?</summary>

  트랜잭션(transaction)이란 하나의 논리적인 작업이 100% 모두 적용되거나 어무것도 적용되지 않아야함을 보장하는 일련의 작업 단위입니다.
</details>
<details>
  <summary>1-1. 트랜잭션의 성질에 대해 설명해주세요.</summary>

  트랜잭션은 안전하게 수행됨을 보장하기 위해 ACID를 만족해야 합니다.

### 원자성(atomicity)
원자성은 트랜잭션의 작업들이 모두 성공하거나 모두 실패해야함을 보장해야 합니다.
### 일관성(consistency)
일관성은 트랜잭션 수행 전과 후의 데이터베이스 상태는 일관적이어야 함을 보장해야 합니다.
### 독립성(isolation)
서로 다른 트랜잭션은 다른 트래잭션의 작업에 끼어들어서는 안 됩니다.
### 지속성(durability)
성공적으로 수행된 트랜잭션은 데이터베이스에 영구적으로 반영되어야 합니다.
</details>
<details>
  <summary>1-2. commit과 rollback에 대해 설명해주세요.</summary>

  commit은 RDBMS에서 트랜잭션을 종료하고 작업 내용을 데이터베이스에 반영하는 명령어입니다. rollback은 작업 내용을 데이터베이스에 반영하지 않고 트랜잭션을 되돌리는 명령어입니다.
</details>

---

<details>
  <summary>2.  트랜잭션의 격리 수준에 대해 알고 있나요?</summary>

격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 결정하는 것입니다. 트랜잭션 격리 수준은 `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE` 4단계로 나뉘어지며 수준이 올라갈 수록 데이터 격리 정도가 높아지지만 동시 처리 성능이 떨어집니다. 일반적으로 `READ COMMITTED`, `REPEATABLE READ` 중 하나를 사용합니다.
</details>
<details>
  <summary>2-1. 각 격리 수준에 대해서 아는대로 설명해주세요.</summary>

### READ UNCOMMITTED
각 트랜잭션의 변경 내용이 `commit`, `rollback` 여부에 상관없이 다른 트랜잭션에서 보이는 더티 리드(dirty read)가 발생합니다.
### READ COMMITTED
어떤 트랜잭션에서 데이터 변경이 발생하면 commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있습니다. 이 수준에서 더티 리드는 발생하지 않으나 하나의 트랜잭션 내에서 똑같은 `select` 쿼리를 실행했을 때 서로 다른 결과를 가져오는 논 리피터블 리드(non repeatable read)가 발생합니다.
### REPEATABLE READ
다른 트랜잭션의 변경 내용이 commit 되어도 현재 진행중인 트랜잭션에서는 변경 전의 내용을 읽을 수 있습니다.
이 수준에서 더티 리드, 논 리피터블 리드가 발생하지 않습니다. 그러나 잠금을 동반한 select 쿼리 사용 시 MVCC를 이용하지 않고 현재 레코드 값을 읽어오기 때문에 팬텀 리드(phantom read)가 발생합니다.
### SERIALIZABLE
특정 트랜잭션이 사용중인 테이블의 모든 레코드를 다른 트랜잭션에서 접근할 수 없도록 잠급니다. 이 수준에서는 단순한 `select` 쿼리만 실행해도 공유락을 획득하며 다른 트랜잭션에서는 해당하는 레코드를 변경하지 못하게 됩니다.
</details>
<details>
  <summary>2-2. MySQL의 격리 수준에 대해서 알고 있나요?</summary>

MySQL의 InnoDB 스토리지 엔진에서는 `REPEATABLE READ`를 기본 격리 수준으로 사용합니다. MVCC를 위해 별도의 공간에 백업된 변경 전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장합니다.

</details>

---

<details>
  <summary>3. 데이터베이스의 잠금이란 무엇인가요?</summary>

  잠금(lock)이란 여러 개의 트랜잭션에서 하나의 데이터로 동시에 접근하려는 경우 이를 제어하기 위한 기능입니다.
</details>
<details>
  <summary>3-1. 잠금은 어떤 종류가 있나요?</summary>

잠금에는 공유락(shared lock)과 배타락(exclusive lock)이 있습니다.
### 공유락
공유락은 락을 획득한 트랜잭션이 끝날때까지 조회한 데이터가 변경되지 않음을 보장하는 잠금입니다. 해당 레코드에 대해 다른 트랜잭션이 공유락은 획득할 수 있지만 배타락을 획득할 수 없습니다.
### 배타락
배타락은 락을 가지고 있는 트랜잭션이 데이터의 변경을 위해 사용하는 잠금입니다. 다른 트랜잭션은 해당 레코드에 대해 공유락과 배타락을 획득할 수 없습니다.
</details>
<details>
  <summary>3-2. 잠금으로 인해 발생할 수 있는 문제에 대해 알고 있나요?</summary>

두 개 이상의 트랜잭션이 특정 자원의 잠금을 획득한 채 서로 다른 트랜잭션이 소유하고 있는 잠금을 획득하기 위해 대기하는 경우 교착상태(deadlock)가 발생할 수 있습니다.
</details>

---

<details>
  <summary>4. 이상 현상이란 무엇인가요?</summary>

  이상 현상이란 하나의 개체에 속한 속성(attribute)들 간에 존재하는 여러개의 종속관계(dependency)를 하나의 릴레이션으로 표현하기 때문에 발생하는 현상들을 말합니다. 이러한 이상 현상은 삭제 이상, 삽입 이상, 갱신 이상이 있습니다.
</details>
<details>
  <summary>4-1. 각각의 이상 현상에 대해 설명해주세요.</summary>

### 삽입 이상
삽입 이상(insertion anomaly)이란 원하지 않는 정보의 강제 삽입을 말합니다.
### 삭제 이상
삭제 이상(deletion anomaly)이란 하나의 정보를 삭제함으로 인해 삭제되길 원치 않는 정보까지 연쇄 삭제되어 발생하는 정보 손실을 뜻합니다.
### 갱신 이상
갱신 이상(update anomaly)이란 하나의 정보를 갱신하고자 할 때 중복 데이터 중 일부만 갱신하게 되어 정보의 모순성이 발생하는 것을 뜻합니다.
</details>
<details>
  <summary>4-2. 이상 현상을 해결하기 위한 방법은 무엇인가요?</summary>

  내용이상 현상을 해결하기 위해서는 속성들 값을 종속성을 분석하여 하나의 테이블이 오직 하나의 종속성만을 가지도록 분해해 나가는 과정을 거쳐야 하며 이를 정규화(normalization) 과정이라 합니다.
</details>
<details>
  <summary>4-3. 정규형에 대해 아는대로 설명해주세요.</summary>

정규형은 기본 정규형과 고급 정규형으로 나뉠수 있으며 일반적으로 기본 정규형까지 고려합니다.
### 1차 정규형
모든 속성의 도메인은 원자값으로 구성되어야 합니다.
### 2차 정규형
모든 속성은 기본키에 완전 함수 종속이어야 합니다.
### 3차 정규형
기본키가 아닌 모든 속성이 기본키에 이행 함수 종속이 되지 않아야 합니다.
### 보이스-코드 정규형(BCNF)
모든 결정자는 후보키에 속해야 합니다.
</details>

<details>
  <summary>4-#. 함수 종속이란?</summary>

#### 함수 종속
- 어느 시점에서든 릴레이션 내에서 속성 X의 값 각각에 대해 속성 Y의 값이 하나라면
    - 속성 X는 속성 Y를 함수적으로 결정한다.
    - 속성 Y는 속성 X에 함수 종속된다. (X -> Y)
    - 이때 속성 X를 결정자(determinant), 속성 Y를 종속자(dependent)라 한다.
#### 완전 함수 종속과 부분 함수 종속
- 2개 이상으로 구성된 속성의 집합 X에 대하여 X -> Y가 성립할 때
    - 속성 X'가 속성 X에 속하고 X' -> Y가 성립되는 애트리뷰트가 존재하지 않을 때 완전 함수 종속이라 한다.
    - 속성 X'가 속성 X에 속하고 X' -> Y가 성립되는 애트리뷰트가 존재할 때 부분 함수 종속이라 한다.
#### 이행 함수 종속
- 릴레이션 R에 함수 종속 A -> B가 존재하고 함수 종속 B -> C가 성립할 때, 애트리뷰트 C는 애트리뷰트 A에 이행 함수 종속이라고 한다.
</details>

---

<details>
  <summary>5. 인덱스란 무엇인가요?</summary>

인덱스(index)는 책의 가장 끝에 있는 찾아보기와 같습니다. 사전 순으로 정렬되어 있고 페이지 번호가 명시되어 있는 것과 같이 컬럼의 값과 해당 레코드가 저장된 주소를 키-값 쌍으로 하여 빠르게 찾아볼 수 있도록 정렬해서 저장한 자료 구조를 인덱스라 합니다.
</details>
<details>
  <summary>5-1. 인덱스의 저장 방식에는 어떤 것이 있나요?</summary>

  인덱스의 저장 방식은 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있습니다.
### B-Tree 인덱스
B-Tree 알고리즘은 가장 일반적으로 사용하는 인덱스 알고리즘입니다. 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된(balanced) 상태로 유지합니다.
### Hash 인덱스
Hash 인덱스 알고리즘은 컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘이며 매우 빠른 검색을 지원합니다. 단, 값을 변형해서 인덱싱하므로 prefix 검색이나 범위를 검색하는데 해시 인덱스를 사용할 수 없습니다.
</details>
<details>
  <summary>5-2. B-Tree의 구조에 대해서 설명해주세요.</summary>

B-Tree는 트리 구조의 최상위에 루트 노드(Root node)가 존재하고 하위에 자식 노드가 붙어 있는 형태입니다. 하나의 루트 노드와 트리 구조 가장 하위에 있는 리프 노드(Leaf node), 루트와 리프 중간에 있는 브랜치 노드(Branch node)로 구성되어 있습니다. 리프 노드에는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있습니다.
</details>
<details>
<summary>5-3. 커버링 인덱스에 대해 설명해주세요.</summary>

</details>

---

<details>
  <summary>6. 인덱스를 사용할 때 고려해야 하는 점은 무엇이 있나요?</summary>

B-Tree 인덱스는 항상 정렬된 상태를 유지합니다. 이로 인해 변경 작업이 이루어지는 경우 해당 변경을 인덱스에도 반영해주는 작업이 추가로 필요합니다. 또한, 인덱스의 키 값이 중복이 많을 수록 검색 대상이 늘어나기 때문에 효율성이 떨어집니다. 따라서 수정 빈도, 카디널리티, 조회 시 얼마나 자주 사용되는지에 따라 적절한 컬럼을 선정해 인덱스의 키로 선택해야 합니다.
</details>
<details>
  <summary>6-1. 클러스터링 인덱스와 세컨더리 인덱스의 차이는 무엇인가요?</summary>

클러스터링 인덱스(clustering index)는 테이블의 프라이머리 키에 대해서만 적용됩니다. 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현합니다.
세컨더리 인덱스(secondary index)는 `create index`와 같이 직접 생성하거나 유니크 제약조건과 같이 자동으로 생성되는 인덱스를 말합니다.


### 클러스터드 인덱스

인덱스의 키 값을 기준으로 정렬되어 있는 구조를 클러스터드 인덱스라고 합니다. MySQL InnoDB에서 모든 테이블은 프라이머리 키를 기준으로 클러스터링 되어 저장됩니다.

### 논 클러스터드 인덱스

논 클러스터드 인덱스는 클러스터드 인덱스와 반대로 키값을 기준으로 데이터가 정렬되지 않는 인덱스를 말합니다.

### 세컨더리 인덱스

세컨더리 인덱스는 사용자가 생성하거나 제약조건에 따라서 만들어진 인덱스가 여기에 속하며, 세컨더리 인덱스에서 검색을 수행한 후 클러스터드 인덱스에 다시 검색을 수행하게 됩니다.

</details>

---

<details>
  <summary>7. MVCC란 무엇인가요?</summary>

MVCC(Multi Version Concurrency Control)는 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능입니다. 하나의 레코드에 대해 여러 개의 버전을 동시에 관리함으로써 잠금을 사용하지 않는 일관된 읽기를 제공하는데 목적이 있습니다.

</details>

---

<details>
  <summary>8. 내부 조인과 외부 조인의 차이는 무엇인가요?</summary>

내부 조인(Inner Join)은 두 테이블에서 조건을 만족하는 레코드들을 매칭하기 위해 사용하는 명령입니다. 외부 조인(Outer Join)은 한 쪽 또는 양 쪽 테이블을 기준으로 매칭되는 값들을 함께 가져오기 위해 사용하는 명령입니다.

</details>

---

<details>
  <summary>9. 기본 키와 유니크 키의 차이에 대해서 설명해주세요.</summary>

기본키는 테이블의 각 레코드를 유일하게 식별하기 위해서 선택된 컬럼의 집합입니다. 각 테이블은 오직 하나의 기본 키만을 가질 수 있으며 자동으로 생성됩니다.
유니크 키는 각 레코드에서 중복되지 않는 값을 가진 컬럼의 집합입니다.
</details>

---

<details>
  <summary>10. 낙관적 락과 비관적 락</summary>

### 낙관적 락
트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법입니다. version을 관리하기 위한 별도의 컬럼을 추가하여 애플리케이션 단에서 락을 구현합니다. 이 방법은 트랜잭션을 커밋하기 전까지는 충돌을 알 수 없다는 특징이 있습니다.

### 비관적 락
트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법입니다. 데이터베이스가 제공하는 공유락 또는 배타락을 이용하여 구현합니다.
</details>

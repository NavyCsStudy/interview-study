<details>
  <summary>1. 트랜잭션이란 무엇인가요</summary>
  트랜잭션은 데이터베이스에서 수행되는 작업의 단위를 나타낸다.<br>
  일련의 연산들을 묶어서 하나의 논리적인 작업 단위로 처리하며, 이 작업들은 모두 성공적으로 완료(Commit)되거나 아무것도 수행되지 않은 상태(Rollback)로 남게 된다.<br>
  이를 통해 데이터베이스의 정합성을 유지하고, 데이터베이스 시스템이 예기치 않은 문제로부터 회복할 수 있게 한다.
</details>
<details>
  <summary>1-1. 트랜잭션의 격리수준에 대해서 아는대로 말씀해주세요.</summary>
  격리수준(Isolation Level)이란, 다수의 트랜잭션이 동시에 처리될 때, 한 트랜잭션이 다른 트랜잭션의 변경 데이터를 볼 수 있게 허용하는지의 여부를 결정하는 수준을 말한다.<br>
  <li>READ UNCOMMITED:<ul>
    <li> 가장 낮은 격리 수준</li>
    <li> 아직 커밋하지 않은 데이터 조차도 볼 수 있는 격리 수준이다.</li>
    <li> 다른 트랜잭션의 작업이 commit 혹은 rollback 되지 않아도 즉시 보인다.</li></ul>
    </li>
  <li>READ COMMITED:<ul>
    <li> 커밋된 데이터만 볼 수 있는 격리 수준이다.</li></ul>
    </li>
  <li>REPEATABLE READ:<ul>
    <li> 트랜잭션 번호를 참고하여, 자신보다 먼저 실행된 트랜잭션의 데이터만을 조회한다.</li>
    <li> 데이터를 읽어올 때 언두 로그에 저장된 기존 데이터를 가져와 보여주는 격리 수준이다.</li></ul></li>
  <li>SERIALIZABLE:<ul>
    <li> 가장 엄격한 격리 수준</li>
    <li> 트랜잭션을 순차적으로 진행시키는 격리 수준이다.</li>
    <li> 여러 트랜잭션이 동일한 데이터에 동시 접근이 불가능 하여, 어떠한 데이터 부정합 문제도 발생하지 않는다.</li>
    <li> 순차적 실행으로 인해 성능상 단점이 있다.</li></ul></li>
</details>
<details>
  <summary>1-2. 트랜잭션의 4가지 특성에 대해 말씀해주세요.</summary>
  1. 원자성(Atomicity): 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다. <br>
  2. 일관성(Consistency): 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.<br>
  3. 독립성(Isolation): 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.<br>
  4. 영속성(Durability): 완료된 결과는 영구적으로 반영되어야 한다.
</details>

---

<details>
  <summary>2. 정규화에 대해 설명해주세요.</summary>
  하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법입니다.
</details>
<details>
  <summary>2-1. 정규화 장단점</summary>
  <li> 장점:<ul>
    <li> 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다.</li>
    <li> 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.</li></ul></li>
  <li>단점:<ul>
    <li> 릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다.</li>
    <li> + 정규화를 수행한다는 것은 이상현상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.</li></ul></li>
</details>
<details>
  <summary>2-2. 역정규화를 하는 이유</summary>
  역정규화는 중복을 허용하며 Entity를 다시 통합하거나 분할하여 정규화 과정을 통해 도출된 DB 구조를 재조정하는 과정이다.<br>
  정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데, 이로인해 성능이 저하될 우려가 있습니다. 역정규화를 하는 가장 큰 이유는 성능 문제가 있는(읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함입니다.
</details>

---

<details>
  <summary>3. Index에 대해 설명해주시고, 장/단점에 대해 아는대로 말해주세요.</summary>
  Index란 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법입니다.<br>
  예를들어, DB를 책으로 비유하면 데이터는 책의 내용일 것이고, 데이터가 저장된 레코드의 주소는 index 목록에 있는 페이지 번호일 것이다.<br>
  인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠르지만, 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다. 또한 인덱스를 위한 추가공간과 인덱스 관리를 위한 추가 작업이 필요합니다.<br>
  즉, 인덱스는 데이터의 저장 성능을 희생하고 그대신 데이터의 검색 속도를 높이는 기능이라 할 수 있습니다.
</details>
<details>
  <summary>3-1. 그렇다면 DBMS는 Index를 어떻게 관리하고 있나요? Index 자료구조 측면에서 말씀해주세요.</summary>
  인덱스의 자료구조로는 기본적으로 Hash Table과 B+Tree가 있습니다. <br>
  해시 테이블은 Key-Value 쌍으로 데이터를 저장하기 때문에, Key를 사용하여 원하는 자료에 빠르게 접근할 수 있습니다. 하지만  데이터베이스에서는 부등호 연산이 자주 발생하기 때문에 잘 사용되지 않습니다.<br>
  B+Tree는 B-Tree를 개선시킨 것으로, Leaf Node에만 데이터를 저장하며 Leaf Node끼리 Linked List로 연결되어 있기 때문에 값을 찾을 때 선형 시간이 걸리게 됩니다.
</details>
<details>
  <summary>3-2. Clustered Index와 Non-Clustered Index의 차이에 대해서 설명해주세요.</summary>
  클러스터형 인덱스는 테이블 전체가 정렬된 인덱스가 되는 방식입니다. 데이터와 함께 전체 테이블이 물리적으로 정렬됩니다. 클러스터 인덱스는 테이블당 1개씩 허용되고 특정 컬럼을 PK로 지정하면 자동으로 클러스터형 인덱스를 생성합니다. 클러스터 인덱스로 저장될 경우 인덱스가 저장될 때 정렬되면 실제 데이터를 디스크에 기록할 때도 데이터가 정렬됩니다. 논 클러스터 인덱스보다 검색속도에 능하지만 입력, 수정, 삭제는 느립니다.<br>
  논 클러스터 인덱스는 클러스터형 인덱스와는 다르게 물리적으로 테이블을 정렬하진 않고, 별도의 인덱스 페이지를 생성하고 관리하는 방식입니다. 비클러스터형 인덱스는 테이블당 여러개 생성이 가능하며 Unique 키를 지정하면 자동으로 생성된다고 합니다. 또한 별도의 장소에 인덱스 페이지를 추가하므로 용량을 더 차지하게 됩니다.<br>
  결국 클러스터 인덱스는 데이터 위치를 바로 알기 때문에 데이터로 접근할 수 있고, 넌 클러스터 인덱스는 인덱스 페이지를 한 번 거쳐서 데이터에 접근하는 방식입니다.
</details>

---

<details>
  <summary>4. DB 락에 대해 설명해주세요.</summary>
  락은 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock이라는 2개의 연산을 이용해 제어하는 것을 말한다. <br>
  종류로는 여러가지가 있는데 일단 위치에 따라 데이터베이스, 파일, 테이블, 레코드 락이 있습니다. <br>
  보통 흔하게 많이 얘기하는 레코드 락중에 배타락, 공유락이 있습니다.
  <li>공유락(Shared Lock) : 한 트랜잭션이 데이터에 대해 공유락을 가지면, 다른 트랜잭션은 해당 데이터를 read 할 수 있지만 write는 할 수 없다. 그리고 다른 트랜잭션도 동시에 해당 데이터에 대한 공유락을 가질 수 있다.</li>
  <li>배타락(Exclusive Lock) : 한 트랜잭션이 데이터에 대해 배타락을 가지면, 다른 트랜잭션은 해당 데이터를 read 할 수도, write 할 수도 없다. 그리도 다른 트랜잭션도 동시에 해당 데이터에 대한 공유락, 배타락을 모두 가질 수 없다.</li>
</details>
<details>
  <summary>4-1. 교착상태란 무엇인가요?</summary>
  여러 transaction들이 자신의 데이터에 대해 lock을 획득한 상태에서 상대방 데이터에 대해 접근하고자 대기를 할 때 교차 대기를 하게 되면서 서로 영원히 기다리는 상태를 말한다.
</details>
<details>
  <summary>4-2. 데드락을 예방하거나 해결하기 위한 방법에 대해 말씀해주세요.</summary>
  데드락 예방: 발생 조건 중 하나 이상을 무효화시킴으로써 데드락이 발생하지 않도록 하는 방법입니다. 예를 들어, 리소스 요청을 한번에 요청하게 해서 점유 및 대기 조건을 제거할 수 있습니다.<br>
  데드락 감지: 시스템에서 주기적으로 데드락을 감지하고, 감지된 데드락을 해결하기 위해 특정 프로세스나 트랜잭션을 중단시키는 방법입니다.<br>
  데드락 회피: 프로세스나 트랜잭션에 리소스를 할당할 때 안전성 검사를 수행하여 데드락의 발생 가능성이 있는 상황을 회피하는 방법입니다.
</details>

---

<details>
  <summary>5. 조인이란 무엇이고, 어떤 조인이 있는지 말씀해주세요.</summary>
  JOIN은 두 개 이상의 테이블을 결합하여 데이터를 검색하는 방법이다. <br>
  관계형 데이터베이스는 중복 데이터를 방지하기 위해 여러 테이블로 나누어 데이터를 관리한다. 그러므로 하나의 데이터를 찾기 위해 여러 테이블을 참조해야하는 경우가 하며, 이때 JOIN을 사용한다.
  <li>Inner Join: 두 테이블에 모두 지정한 열의 데이터가 있어야 결과로 포함</li>
  <li>Outer Join: 기준이 되는 테이블에만 데이터가 있어도 결과로 포함. 이때 기준이 아닌 테이블에 데이터가 없는 경우는 null로 표시</li>
  <li>Cross Join: 한쪽 테이블의 모든 행과 다른 쪽 테이블의 모든 행을 조인하는 기능</li>
  <li>Self Join: 자신이 자신과 조인한다는 의미</li>
</details>
<details>
  <summary>5-1. inner join과 outer join의 차이에 대해 설명해주세요.</summary>
  <li>inner join은 서로 연관된 내용만 검색하는 조인 방법이다.<ul>
    <li> A와 B에 대해 수행하는 것은, A와 B의 교집합을 말한다.</li></ul></li>
  <li>outer join은 한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을 전부 출력하는 방법이다.<ul>
    <li> A와 B에 대해 수행하는 것은, A와 B의 합집합을 말한다.</li>
    <li> outer join에는 기준 테이블의 방향에 따라 LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN이 있다.</li></ul></li>
</details>

---

<details>
  <summary>6. MVCC가 무엇인지 설명해주세요.</summary>
  MVCC는 레코드 레벨의 트랜잭션을 지원하는 기능으로 잠금을 사용하지 않는 일관된 읽기를 언두 로그를 통해 제공합니다. 커밋되기 이전에 변경 되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환하며 잠금을 필요로 하지 않기 때문에 일반적인 DBMS보다 빠릅니다.
</details>

---

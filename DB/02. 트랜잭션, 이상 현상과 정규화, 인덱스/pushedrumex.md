<details>
  <summary>1. Mysql 에서 조회쿼리는 트랜잭션 격리 수준에 따라 다르게 처리되는데, 어떤 원리로 동작하는지 알고계신다면 설명해주세요.</summary>
  MVCC 를 통해 격리 수준에 따라 데이터를 다르게 처리합니다. 언두 로그를 통해 갱신되기 전의 데이터를 보관하고, 격리 수준에 따라 버퍼풀 또는 언두 로그에 있는 데이터를 조회합니다.
</details>
<details>
  <summary>1-1. MVCC 의 단점이 무엇인지 자유롭게 말해보세요.</summary>
  트랜잭션이 길 경우, 언두 로그의 데이터가 계속해서 쌓이게 되어 언두 로그의 크기가 커지는 단점이 있습니다. 이를 해결하기 위해서는 트랜잭션을 가능한 작게 유지해야 합니다.
</details>
<details>
  <summary>1-2. 만약 READ COMMITED 격리수준에서 1번 트랜잰션이 특정 데이터를 갱신하고 커밋하지 않은 상태에서 2번 트랜잭션이 시작되어 해당 데이터를 조회했다면, 해당 데이터를 언두로그에서 불러올까요 아니면 버퍼풀에서 불러올까요?</summary>
  READ COMMITED 격리수준에서는 다른 트랜잭션에 커밋을 완료한 데이터만 조회할 수 있기 때문에 갱신되기 전의 데이터가 존재하는 언두로그에서 데이터를 불러옵니다.
</details>

---

<details>
  <summary>2. 트랜잭션이란 무엇인가요?</summary>
  트랜잭션이란 사용되는 쪼갤 수 없는 업무처리의 단위입니다. 트랜잭션의 특성에는 ACID 가있습니다.
    원자성은 트랜잭션의 처리는 완전히 끝마치지 않았을 경우에는 전혀 이루어지지 않은 것과 같아야 한다는 성질입니다.
    일관성은 트랜잭션이 시작하기 전에도 테이블의 제약조건을 지키고 있을 것이고, 트랜잭션이 끝나도 이 제약조건에 맞아야한다는 성질입니다.
    격리성은 트랜잭션은 다른 트랜잭션의 작업에 영향을 받지 않아야 한다는 성질입니다.
    지속성은 트랜잭션이 커밋되면 끝나면 그 결과는 영구적으로 반영되어야 한다는 성질입니다.
</details>
<details>
  <summary>2-1. 트랜잭션 격리 수준에 대해 설명해주세요.</summary>
  트랜잭션 격리수준에는 READ UNCOMMITED, READ COMMITED, REPEATABLE READ, SERIALIZABLE 이 있습니다.
    READ UNCOMMITED 는 다른 트랜잭션에 커밋되지 않은 데이터를 읽을 수 있습니다. 터디 리드가 발생할 수 있습니다.
    READ COMMITED 는 다른 트랜잭션에 커밋된 데이터만 읽을 수 있습니다. 터디 리드는 발생하지 않지만, PHANTOM READ 가 발생할 수 있습니다.
    REPEATABLE READ 는 같은 쿼리를 실행해도 항상 같은 결과를 보장합니다. PHANTOM READ 가 발생할 수 있습니다.
    SERIALIZABLE 은 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없습니다.
</details>
<details>
  <summary>2-2. Innodb 에서 REPEATABLE READ 격리수준에서도 PHANTOM READ 가 발생하나요?</summary>
  Innodb 에서는 갭락을 지원하기 때문에 REPEATABLE READ 격리수준에서는 일반적으로 PHATOM READ 가 발생하지 않습니다.\
    하지만 locking 조회일 경우 언두 영역의 레코드에는 lock 을 걸 수 없기 때문에 현재 레코의 값을 가져오게 되는데
    만약 non-locking 조회 후 locking 조회를 했다면 PHANTOM READ 가 발생할 수 있습니다. 
</details>

---

<details>
  <summary>3. join 이란 무엇인가요?</summary>
  데이터베이스에서 두개 이상의 테이블을 연결하여 하나의 결과의 테이블로 만드는 것을 의미합니다.
</details>
<details>
  <summary>3-1. 내부 조인과 외부 조인에 대해 설명해주세요.</summary>
  내부 조인은 두 테이블의 교집합을 구하는 것이고, 외부 조인은 두 테이블의 합집합을 구하는 것입니다. 외부조인에는 LEFT, RIGHT, FULL OUTER JOIN 이 있습니다.
</details>
<details>
  <summary>3-2. join 알고리즘 중 알고 있는게 있다면 한가지만 설명해주세요.</summary>
  Nested Loop join 은 두 테이블 중 하나의 테이블을 기준으로 다른 테이블을 순회하면서 조인하는 방식입니다.\
    이 방식은 두 테이블 중 하나의 테이블의 크기 작은 경우에 유리하고, 인덱스를 사용할 수 있을 때 유리합니다.
</details>

---

<details>
  <summary>4. 인덱스란 무엇인가요?</summary>
  인덱스는 데이터베이스 테이블의 특정 컬럼에 대한 검색 및 조회 성능을 향상시키기 위한 자료 구조입니다.
</details>
<details>
  <summary>4-1. B-tree 와 Hash 자료구조를 사용해서 인덱스를 구현할 수 있는데, B-tree 가 가장 많이 사용되는 이유가 무엇일까요?</summary>
  Hash 자료구조는 등호 연산에 최적화 되어있지만 범위 연산을 불가능합니다. B-tree 는 범위 연산에도 사용할 수 있기 때문에 더 많이 사용됩니다.
</details>
<details>
  <summary>4-2. B-Tree 인덱스에서 인덱스 추가 작업이 오래걸리는 이유에 대해서 아시나요?</summary>
  새로운 인덱스를 추가하려면 일단 B-Tree 상에서 적절한 위치를 검색하고 인덱스와 데이터 주소 정보를 리프 노드에 저장합니다. 또한, 리프 노드에 꽉 차 있을 경우 리프 노드를 분리하는 작업도 추가되기 때문에 오래걸립니다.
</details>

---

<details>
  <summary>5. 클러스터링 인덱스란 무엇인지 설명해주세요</summary>
  프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 인덱스입니다.
</details>
<details>
  <summary>5-1. 클러스터링 인덱스와 보조 인덱스의 리프 노드에 저장되는 정보의 차이에 대해서 설명해주세요.</summary>
    클러스터링 인덱스는 데이터 레코드 자체를 리프 노드에 저장하고, 보조 인덱스는 데이터 레코드의 PK를 리프 노드에 저장합니다.
</details>
<details>
  <summary>5-2. InnoDB 이서 인덱스를 자동으로 생성해주는 제약조건은 어떤 것들이 있나요?</summary>
    프라이머리 키, 유니크 키, 외래 키에 대해서는 자동으로 인덱스를 생성해줍니다.
</details>

---

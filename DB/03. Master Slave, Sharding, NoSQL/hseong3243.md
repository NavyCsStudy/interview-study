<details>
  <summary>1. Replication에 대해 설명해주세요.</summary>

  복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말합니다. 원본 데이터를 가진 소스(Source) 서버와 복제된 데이터를 가지는 레플리카(Replica) 서버를 두어 스케일 아웃, 데이터 백업, 데이터 분석, 데이터의 지리적 분산과 같은 목적 얻기 위함입니다.
</details>
<details>
  <summary>1-1. MySQL의 Replication은 어떻게 이루어지나요?</summary>

MySQL 서버의 모든 변경 사항은 바이너리 로그(Binary Log)라는 별도의 로그 파일에 순차적으로 기록됩니다. 소스 서버에서 생성된 바이너리 로그가 레플리카 서버에 전송되면 레플리카 서버는 해당 내용을 로컬 디스크에 릴레이 로그(Relay Log)라는 파일로 저장한 뒤 자신이 가진 데이터에 반영하여 소스 서버와 레플리카 서버간의 동기화가 이루어집니다.
</details>

---

<details>
  <summary>2. Sharding이란 무엇인가요?</summary>

  샤딩은 데이터베이스의 수평적 확장 방법으로써 대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하여 여러 대의 서버에 저장하는 기술을 말합니다. 모든 샤드는 동일한 스키마를 사용하지만 샤드에 보관되는 데이터 사이에는 중복이 없습니다.
</details>
<details>
  <summary>2-1. 샤딩에는 어떤 방법이 있나요?</summary>

#### 범위 기반 샤딩(Range sharding)
범위 기반 샤딩은 PK 값의 범위를 기준으로 데이터베이스 행을 분할하는 방법입니다. 모듈러 샤딩에 비해 데이터베이스의 증설이 쉬우나 활성유저가 몰린 데이터베이스로 트래픽이 집중 될 수 있습니다.
#### 모듈러 샤딩(Modular sharding)
모듈러 샤딩은 PK 값의 모듈러 연산 결과로 데이터베이스를 특정하는 방법입니다. 범위 기반 샤딩에 비해 데이터가 균일하게 분산되나 데이터베이스를 추가로 증설하는 경우 적재된 데이터의 재정렬이 필요합니다.
</details>
<details>
  <summary>2-2. 샤딩과 파티셔닝의 차이는 무엇인가요?</summary>

파티셔닝은 데이터베이스 테이블을 여러 그룹으로 분할하는 프로세스입니다. 파티셔닝은 2가지 유형으로 분류됩니다.

#### 수평 파티셔닝
데이터베이스를 행별로 분할합니다.
#### 수직 파티셔닝
데이터베이스 열별로 서로 다른 파티션을 만듭니다.

데이터베이스 샤딩은 수평 파티셔닝과 유사합니다. 두 작업 모두 데이터베이스를 여러 개의 고유 행 그룹으로 분할합니다. 단, 파티셔닝은 모든 데이터 그룹을 동일한 컴퓨터에 저장하나 샤딩은 서로 다른 컴퓨터에 분산 저장한다는 차이점이 있습니다.
</details>

---

<details>
  <summary>3. NoSQL이란 무엇인가요?</summary>

  NoSQL이란 관계형 데이터베이스의 엄격한 스키마에서 벗어나 다양한 형태의 데이터 저장 및 처리를 지원하는 데이터베이스입니다. NoSQL 데이터베이스는 대량의 분산된 데이터를 다루거나 유연한 데이터 모델이 필요한 경우 유용하며 스키마가 느슨하거나 동적이며, 수평적 확장이 가능하도록 설계되어 있습니다.
</details>
<details>
  <summary>3-1. RDB 와 NoSQL의 차이에 대해 설명해주세요.
</summary>

  RDB는 엄격한 스키마를 정해진 형식에 맞게 데이터를 저장합니다. 데이터 중복이 없기 때문에 update가 용이합니다. 그러나 유연성이 떨어져 추후 스키마의 수정이 어려우며, 시스템이 복잡해질수록 조인문이 많은 복잡한 쿼리가 발생하게 됩니다.

반면 NoSQL의 경우 유연한 데이터 구조를 가지며 새로운 필드를 자유롭게 추가할 수 있습니다. 하지만 데이터 중복이 발생할 수 있기 때문에 값을 업데이트하려는 경우 모든 컬렉션에서 수정이 필요합니다.
</details>
<details>
  <summary>3-2. NoSQL의 종류는 어떤 것들이 있나요?</summary>

NoSQL은 저장 방식에 따라 key-value, document, graph, column로 분류할 수 있습니다.
#### Key-Value
키-값 데이터베이스는 데이터를 키-값 쌍으로 저장합니다.
#### Document
문서 데이터베이스는 JSON 형식의 유연한 동적 문서에 데이터를 저장합니다.
#### Column
하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회합니다.
#### Graph
그래프 데이터베이스는 데이터 간의 복잡한 관계를 관리하도록 설계되었습니다. 데이터는 노드와 에지로 저장되며 노드는 개체, 에지는 이들 간의 관계를 나타냅니다.
</details>

---

<details>
  <summary>4. Redis의 목적은 무엇인가요?</summary>

레디스는 데이터베이스, 캐시, 메시지 브로커 등으로 사용할 수 있는 인메모리 데이터 구조의 오픈 소스 저장소입니다.
</details>
<details>
  <summary>4-1. Redis의 자료 구조에는 어떤 것들이 있나요?</summary>

  레디스는 Strings, JSON, Sets, Lists, Hashes, Sorted sets 등 다양한 자료 구조를 제공하고 있습니다.
#### Strings
문자열은 Redis 키에 연결할 수 있는 가장 간단한 유형의 값입니다. 
#### Lists
Lists는 링크드 리스트로 구현되어 데이터를 저장할 수 있는 자료 구조입니다.
#### Sets
Sets은 순서가 보장되지 않는 고유한 문자열 집합입니다.
#### Hashes
해시는 key-value 쌍의 컬렉션으로 구조화한 자료 구조입니다.
#### Sorted sets
Sorted sets는 연관된 점수에 따라 정렬되어 있는 고유한 문자열의 집합입니다.
</details>
<details>
<summary>4-2. Redis는 단일 스레드인데 어떻게 빠른 성능을 제공할 수 있을까요?</summary>

</details>

---

<details>
  <summary>5. 캐시란 무엇인가요?</summary>

  캐시는 값비싼 연산 결과나 자주 참조되는 데이터를 메모리 안에 두고, 향후 요청을 보다 빨리 처리될 수 있도록 하는 저장소입니다. 데이터베이스의 호출 횟수를 줄여 애플리케이션의 성능을 개선하는데 사용할 수 있습니다.
</details>
<details>
  <summary>5-1. 로컬 캐시와 글로벌 캐시의 차이는 무엇인가요?</summary>

#### 로컬 캐시
로컬 캐시는 서버마다 캐시를 따로 저장하며 다른 서버의 캐시를 참조하기 어렵습니다. 로컬에서 작동하기 때문에 서버와 자원을 공유하지만 그만큼 빠른 속도를 가지고 있습니다.

#### 글로벌 캐시
글로벌 캐시는 별도의 캐시 서시를 두어 여러 서버가 동일한 캐시를 참조할 수 있습니다. 별도의 서버에서 작동하기 때문에 네트워크 트래픽이 발생하며 로컬 캐시보다는 속도가 느립니다.
</details>
<details>
  <summary>5-2. 캐시 패턴에는 어떤 것들이 있나요?</summary>

대표적인 전략 두 가지로 요청이 이루어진 뒤 캐시하는 cache-aside와 데이터가 업데이트 되는 즉시 캐시하는 write-through가 있습니다.
#### Cache-aside(Lazy loading)
사용자의 요청이 발생했을 때 다음과 같은 과정을 거칩니다.
1. 캐시 확인
2. 캐시에 데이터가 있는 경우 캐시된 데이터를 반환(캐시 히트)
3. 캐시에 데이터가 없는 경우 데이터베이스에서 조회(캐시 미스)
4. 조회한 데이터를 캐싱하고 사용자에게 반환

cache-aside의 장점은 실제 요청이 발생하는 데이터만 캐시한다는 점, 레디스의 장애가 애플리케이션에 치명적인 영향을 주지 않는다는 점입니다. 단점은 캐시 미스가 발생했을 때 오버헤드가 발생한다는 점, 캐시가 최신 데이터를 가지고 있다는 것을 보장하지 못하는 점이 있습니다.
#### Write-through
데이터의 변경이 수행될 때 다음과 같은 과정을 거칩니다.
1. 애플리케이션에서 데이터베이스를 업데이트합니다.
2. 즉시 변경된 데이터가 캐시에 반영됩니다.

write-through의 장점은 캐시의 데이터가 항상 최신 상태로 유지된다는 점입니다. 그러나 데이터가 변경될 때마다 캐시에 반영하는 작업으로 인해 오버헤드가 발생한다는 점, 자주 조회되지 않는 데이터도 캐시에 저장하여 리소스가 낭비된다는 단점이 있습니다.

이 외의 다른 패턴으로는 read-through, write-back, write-around 패턴이 있습니다.
#### Read-through
cache-aside와 동일하게 lazy loading으로 데이터를 가져옵니다. 애플리케이션이 아닌 캐시 제공자가 데이터 동기화를 수행합니다.
#### Write-back
데이터 저장 시 DB에 곧바로 저장하지 않고 캐시에 일정 시간동안 모아뒀다가 저장합니다. 데이터 정합성을 확보할 수 있지만 캐시에 장애가 발생하면 데이터가 유실된다는 단점이 있습니다.
#### Write-around
모든 데이터는 곧바로 데이터베이스에 저장됩니다. 쓰기 작업 중에는 캐시에 데이터가 저장되지 않습니다. 캐시 미스가 발생했을 때 데이터베이스로부터 데이터를 가져와 캐시에 저장합니다.
</details>

---

<details>
  <summary>6. CAP 이론에 대해서 설명해주세요.</summary>

일관성(consistency), 가용성(availability), 분할 내성(partition tolerance) 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리입니다.

### 데이터 일관성
분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 제공해야 합니다.
### 가용성
분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 합니다.
### 분할 내성
파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미합니다. 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 합니다.

### CP 시스템
- 일관성과 분할 내성을 지원하는 시스템입니다.
- 네트워크 문제가 발생할 시 새로운 데이터를 반영할 수 있는 상황이 오기 전까지 서버는 오류를 응답합니다.
### AP 시스템
- 가용성과 분할 내성을 지원하는 시스템입니다.
- 네트워크 문제가 발생하면 서버 사이의 일관성이 깨지고 과거의 데이터를 반환한다 하더라도 서버는 반드시 응답합니다.
### CA 시스템
- 일관성과 가용성을 지원하는 시스템입니다.
- 일반적인 상황에서 네트워크 장애는 피할 수 없는 일이므로 분산 시스템은 반드시 분할 내성을 고려하여 설계해야 합니다.
- 실세계에 CA 시스템은 존재할 수 없습니다.

</details>

## 참고

https://aws.amazon.com/ko/what-is/database-sharding/

https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html

https://medium.com/garimoo/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A0%88%EB%94%94%EC%8A%A4-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-02-f1029893e263

https://wikidocs.net/190385
